<link rel="stylesheet" type="text/css" href="../css/blog.css"><div class="cloud-blog-detail-content-wrap the_height"><div class="cloud-blog-detail-content-wrap">
    <div class="cloud-blog-detail-content blog-content-block-0" id="blogContent">
        <p>上周给同事的项目做代码review发现有不少空值处理的问题,由于java里没有像c#里的？.这种写法,很多时候空值处理很容易遗漏,用三目或者条件表达式补上去又会显得比较冗长;</p><p>&nbsp;其实常见的判空场景种类其实并不多, 看了一些帖子,感觉下面的做法就不错了:</p><p>obj.toString() =&gt;&nbsp;java.util.Objects.toString(obj,defaultValue);</p><p>list!=null &amp;&amp; list.size()&gt;0 =&gt;&nbsp;org.springframework.util.CollectionUtils.isEmpty(list)&nbsp;</p><p>//更广泛的可以使用org.springframework.util.ObjectUtils.isEmpty(list)&nbsp;</p><p>参考:</p><p><a rel="nofollow" href="https://stackoverflow.com/questions/12721076/best-practice-to-validate-null-and-empty-collection-in-java">https://stackoverflow.com/questions/12721076/best-practice-to-validate-null-and-empty-collection-in-java</a></p><p><a rel="nofollow" href="https://stackoverflow.com/questions/5522201/any-simple-way-to-test-null-before-convert-an-object-to-string">https://stackoverflow.com/questions/5522201/any-simple-way-to-test-null-before-convert-an-object-to-string</a></p><p><a rel="nofollow" href="https://dzone.com/articles/stringvalueofobject-versus-objectstostringobject">https://dzone.com/articles/stringvalueofobject-versus-objectstostringobject</a> </p><p><a rel="nofollow" href="https://juejin.im/post/5bf60e286fb9a049dd7fe9f8">https://juejin.im/post/5bf60e286fb9a049dd7fe9f8</a></p><p><a rel="nofollow" href="http://shzhangji.com/cnblogs/2018/09/22/how-to-avoid-null-pointer-exception/">http://shzhangji.com/cnblogs/2018/09/22/how-to-avoid-null-pointer-exception/</a> </p><p><a rel="nofollow" href="https://blog.csdn.net/Charein/article/details/17590523">https://blog.csdn.net/Charein/article/details/17590523</a></p><p><a rel="nofollow" href="https://lrwinx.github.io/2018/08/30/java%E5%8C%A0%E4%BA%BA%E6%89%8B%E6%B3%95-%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC/">https://lrwinx.github.io/2018/08/30/java%E5%8C%A0%E4%BA%BA%E6%89%8B%E6%B3%95-%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC/</a></p><p><span style="color:rgb(0,176,80);"><span style="color:rgb(0,176,80);"><span style="color:rgb(0,176,80);">/*------------------- 我目前的观点是，注重编程细节，但是又不能教条的拘泥于细节</span>----------------------------------------------------*/</span></span></p><p><span style="color:rgb(0,176,80);">/*------------------------------StringBuilder/StringBuffer---------------------------------------------------------------*/</span></p><p>1. 划重点</p><ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p>未优化的字符串 + 操作性能最差。比如for循环中重复 + 操作就不会被优化，应该要避免。</p></li><li><p>简单的字符串 + 操作会被编译器优化成 StringBuilder.append 。比如： “This is ” + val + "." ，性能</p></li></ul><p>几乎跟显式使用 StringBuilder.append 一样。（详见JHM测试结果）</p><ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p>StringBuffer几乎不会用到它！ StringBuffer是线程安全的，有加锁开销，性能比StringBuilder稍差。如果你</p></li></ul><p>用到了StringBuffer，请重新审视这么做的合理性和必要性。</p><ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p>StringBuilder在实际项目中使用最多！ StringBuilder后于StringBuffer出现，是StringBuffer的简易替换，取</p></li></ul><p>消了加锁，线程不安全，绝大多数字符串拼接场景都无需线程安全，因此使用最多。各种衍生的拼接类内部都</p><p>用到了它。</p><ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p>StringBuilderHelper（衍生自BigDecimal的ThreadLocal版StringBuilder）更适合大数据量字符串拼接，性</p></li></ul><p>能最好，其内部做到了实例和缓冲区重复利用，也更节省资源。</p><ul class="list-paddingleft-2" style="list-style-type:disc;"><li><p>StringBuilderHelper是一个线程握持一个StringBuilder实例，使用时要清楚这一点。如果想要在一个方法中</p></li></ul><p>使用两个sb实例，则不能这么做：</p><p>StringBuilder sb1 = StringBuilderHelper.getStringBuilder();</p><p>StringBuilder sb2 = StringBuilderHelper.getStringBuilder();</p><p>sb1和sb2其实是同一个实例。</p><p>&nbsp;不同拼接方式性能对比</p><p>1. ThreadLocal版StringBuilder（更适合大数据量的字符串拼接</p><p>2. StringBuilder.append</p><p>3. 优化的+拼接 （简单字符串拼接）</p><p>4. StringBuffer.append</p><p>5. 未优化的+拼接（比如for/while循环）</p><p>建议1：对于大批量字符串拼接，绝大多数情况下，都建议使用StringBuilder。</p><p>建议2：如果真的需要线程安全才使用StringBuffer，但请一定严格审视这么做的必要性。</p><p>这里的toString中不存在循环等复杂语句，属于简单字符串拼接，为了代码简洁性和可读性，建议使用+拼接。不用</p><p>担心性能受影响，因为java编译器已经帮我们自动转换成StringBuilder了(Oracle JDK 1.8/Huawei OpenJDK 1.8上用</p><p>javap验证)。</p><p>建议1：简单字符串拼接，直接用+完成。</p><p>建议2：简单的toString方法，一样建议使用+进行拼接，使得代码更简洁，更符合阅读习惯。</p><p>建议3：对于toString方法，可以进一步使用lombok的@ToString注解简化。</p><p>推荐写法1：简单字符串拼接直接用"+"</p><p>推荐写法2：大批量字符串拼接(非线程安全)</p><p>无需考虑线程安全的场景下，推荐使用StringBuilder字符串拼接</p><p>比StringBuffer性能好，大部分场景下都要考虑采用此接口</p><p>考虑进一步提升大字符串的拼接性能，降低内存占用，考虑使用下一节的StringBuilderHelper技术。</p><p>推荐以局部变量的方式使用来规避多线程竞争问题。</p><p>// 每次都以局部变量使用，这样就能保证不会出现多线程同步问题</p><p>StringBuilder sb = new StringBuilder();</p><p>for (final String s : dataList) {</p><p>sb.append(s);</p><p>}</p><p>return sb.toString();</p><p>直面NullPointerException</p><p>. 划重点</p><p>使用Objects.requireNonNull进行null检查。</p><p>使用Optional包装可能为空的返回值。</p><p>使用Optional简化编程。</p><p>返回零长度的数组或者集合，而不是null。</p><p>. Java String适合存储敏感信息明文吗？</p><p>&nbsp;修改建议</p><p>1. 不要将敏感数据（如密码、密钥）以明文形式存储于内存中，即使是短时间内临时存储。</p><p>2. 建议使用专用类存储明文的敏感信息，或者，将明文敏感信息临时存储在可变数据类型（如：Char数组、字节</p><p>数组）中，且用完后立即擦除。</p><p>使用String Joiner API写出简洁的代码</p><p>&nbsp;划重点</p><p>String Joiner API是围绕着StringBuilder做的一些便利性封装，使得编码更加简洁。</p><p>Java 1.8提供了三个String Joiner API实现：String.join()、StringJoiner和Collectors.joining()。在此之前，</p><p>Apache Commons lang3提供了StringUtils.join()来完成类似功能。</p><p>StringJoiner和Collectors.joining()除了支持分隔符拼接，还支持前缀、后缀的拼接。</p><p>StringJoiner的使用方式跟StringBuilder相似，Collectors.joining()主要结合Stream函数式编程使用。</p><p>更简洁的getter/setter/toString</p><p>Lombok属性访问注解</p><p>1. 为属性提供getter/setter方法 @Getter/@Setter</p><p>2. 为所有属性提供getter、setter、toString、equal等功能 @Data</p><p>3. 覆写toString方法 @toString</p><p>4. hashCode和equal方法 @EqualsAndHashCode</p><p>Lombok使用时需要注意的地方</p><p>1. 名称aType类似的属性使用@Getter</p><p>2. 用了@Data就不要有继承关系</p><p>单例(Singleton)你用对了吗</p><p>&nbsp;划重点</p><p>单例加载的时机可以分为即时加载 和延时加载 两种模式。</p><p>即时加载主要有：枚举类单例、静态公有域单例和静态工厂方法单例。</p><p>推荐程度： 枚举类单例 &gt; 静态工厂方法单例 &gt; 静态公有域单例。</p><p>例外： 如果你的单例类必须要继承某个超类，那么枚举类单例不宜使用。</p><p>延时加载主要有：静态内部类单例和 双重校验锁（DCL）单例。</p><p>推荐静态内部类单例。</p><p>双重校验锁有PMD告警。</p><p>如果没有特殊需要，优先使用即时加载模式的单例。</p><p>对于一些无状态的具有“唯一”特征的类，比如工具类，建议使用静态方法实现。</p><p>更好地申请和关闭资源</p><p>划重点</p><p>传统的 try-finally 方式存在复杂易出错和异常抑制(Suppressed)等问题。</p><p>使用 try-with-resource ，可以更安全、简洁地申请和关闭资源，同时解决了异常抑制问题。</p><p>try-with-resource 是语法糖，其最终仍然会被编译成 try-finally 方式并调用 close 方法关闭资源。</p><p>为了支持 try-with-resource ，资源类必须要实现 AutoClosable 接口，否则无法使用。</p><p>在使用 try-with-resource 之前，请务必确认下资源类是否已经实现了 AutoClosable 接口。</p><p>try-with-resource 使用很简单，申请资源的代码写在try后面的()中即可，无需显式调用 close 方法来关闭资</p><p>源。</p><p>为了使程序更加健壮，在 try-with-resouce 中使用装饰器时，建议显式声明被装饰/包裹对象的引用。</p><p>异常你用对了吗？</p><p>&nbsp;划重点</p><p>对可恢复的情况使用受检异常，对编程错误使用运行时异常。</p><p>不要用异常去控制程序的流程</p><p>切忌使用空catch块</p><p>避免多次在日志信息中记录同一个异常</p><p>在finally块中不要使用return、break或continue使finally块非正常结束</p><p>不要随意捕获Exception基类和Throwable基类，除非场景真的需要</p><p>敏感信息禁止放在异常信息里</p><p>Java 8 Stream了解多少？</p><p>&nbsp;划重点</p><p>Stream API 借助于 Lambda 表达式，为 Collection 操作提供了一个新的选择。如果使用得当，可以极大地提高</p><p>编程效率和代码可读性。</p><p>Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</p><p>审慎地使用 Stream</p><p>综合代码可读性、业务场景等适度使用。</p><p>在很多场景下，选择优雅、可读性好的代码比性能低一点更重要。就比如，我们都知道直接写汇编代码，</p><p>运行性能最高，但我们依然选择高级语言编码一样。关于性能问题，多去尝试、多去测试。</p><p>使用Stream时注意小心函数的副作用。</p><p>使用Stream API实现并发程序变得越来越容易，但编写正确快速的并发程序还像以前一样困难。</p><p>在产品中不建议使用并行Stream。</p><p>XXE与各种库滥用</p><p>1. 划重点</p><p>利用XXE漏洞（XML外部实体注入）可能造成以下攻击风险：</p><p>机密数据泄露</p><p>内部端口扫描</p><p>远程代码执行</p><p>拒绝服务攻击</p><p>预防XXE攻击：通过XML解析器的参数配置进行防护，如果明确不需要DTD时，完全禁止DOCTYPE声明是最好的策略；如果无法避免DTD时，请禁用外部实体。</p><p>对于不同的库，设置XXE防护的方式存在差异。</p><p>合适的封装公共代码块，是降低维护成本、减少风险的方式。</p><p><br></p><p><br></p><p>Effective Java 3</p><p><br></p>
    </div>
    
    
    <p class="pc_current ask-tip">登录后可下载附件，请<a href="https://auth.huaweicloud.com/authui/login?service=https://bbs.huaweicloud.com/blogs/137331#attachment&amp;locale=zh-cn">登录</a>或者<a href="https://reg.huaweicloud.com/registerui/public/custom/register.html?locale=zh-cn&amp;service=https://bbs.huaweicloud.com#/register">注册</a></p>

    <!-- 版权声明 start -->
    
   
    
    <!-- 版权声明 end -->

    <div class="blog-menu-footer m-blog-menu-footer-bottom">
        
    </div>
</div></div>