<link rel="stylesheet" type="text/css" href="../css/blog.css"><div class="cloud-blog-detail-content-wrap the_height"><div class="cloud-blog-detail-content-wrap">
    <div class="cloud-blog-detail-content blog-content-block-0" id="blogContent">
        <p>效果图:</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/1545410883634482.png" title="1545410883634482.png" alt="image.png" class="localImage"></p><p style="white-space:normal;">代码只是对freetype api的简单使用，只是用来验证参考的：</p><pre class="brush:java;toolbar:false">#include&nbsp;&lt;QString&gt;
#include&nbsp;&lt;iostream&gt;
#include&nbsp;&lt;map&gt;
#include&nbsp;&lt;string&gt;
#define&nbsp;GLEW_STATIC
#include&nbsp;&lt;GL/glew.h&gt;
#include&nbsp;&lt;GLFW/glfw3.h&gt;
#include&nbsp;&lt;glm/glm.hpp&gt;
#include&nbsp;&lt;glm/gtc/matrix_transform.hpp&gt;
#include&nbsp;&lt;glm/gtc/type_ptr.hpp&gt;
#include&nbsp;&lt;ft2build.h&gt;
#include&nbsp;FT_FREETYPE_H
#include&nbsp;&lt;freetype/ftglyph.h&gt;&nbsp;.
#include&nbsp;"Shader.h"
const&nbsp;GLuint&nbsp;WIDTH&nbsp;=&nbsp;800,&nbsp;HEIGHT&nbsp;=&nbsp;600;
struct&nbsp;Character&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GLuint&nbsp;TextureID;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2&nbsp;Size;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2&nbsp;Bearing;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;GLuint&nbsp;Advance;&nbsp;&nbsp;&nbsp;&nbsp;
};
std::map&lt;GLshort,&nbsp;Character&gt;&nbsp;Characters;
GLuint&nbsp;VAO,&nbsp;VBO;
void&nbsp;RenderText(Shader&nbsp;&amp;shader,&nbsp;const&nbsp;QString&amp;&nbsp;text,&nbsp;GLfloat&nbsp;x,&nbsp;GLfloat&nbsp;y,&nbsp;GLfloat&nbsp;scale,&nbsp;glm::vec3&nbsp;color);
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;glfwInit();
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,&nbsp;3);
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,&nbsp;3);
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_OPENGL_PROFILE,&nbsp;GLFW_OPENGL_CORE_PROFILE);
&nbsp;&nbsp;&nbsp;&nbsp;glfwWindowHint(GLFW_RESIZABLE,&nbsp;GL_FALSE);
&nbsp;&nbsp;&nbsp;&nbsp;GLFWwindow*&nbsp;window&nbsp;=&nbsp;glfwCreateWindow(WIDTH,&nbsp;HEIGHT,&nbsp;"LearnOpenGL",&nbsp;nullptr,&nbsp;nullptr);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;glfwMakeContextCurrent(window);
&nbsp;&nbsp;&nbsp;&nbsp;glewExperimental&nbsp;=&nbsp;GL_TRUE;
&nbsp;&nbsp;&nbsp;&nbsp;glewInit();
&nbsp;&nbsp;&nbsp;&nbsp;glViewport(0,&nbsp;0,&nbsp;WIDTH,&nbsp;HEIGHT);
&nbsp;&nbsp;&nbsp;&nbsp;glEnable(GL_CULL_FACE);
&nbsp;&nbsp;&nbsp;&nbsp;glEnable(GL_BLEND);
&nbsp;&nbsp;&nbsp;&nbsp;glBlendFunc(GL_SRC_ALPHA,&nbsp;GL_ONE_MINUS_SRC_ALPHA);
&nbsp;&nbsp;&nbsp;&nbsp;Shader&nbsp;shader("shaders/text.vs",&nbsp;"shaders/text.frag");
&nbsp;&nbsp;&nbsp;&nbsp;glm::mat4&nbsp;projection&nbsp;=&nbsp;glm::ortho(0.0f,&nbsp;static_cast&lt;GLfloat&gt;(WIDTH),&nbsp;0.0f,&nbsp;static_cast&lt;GLfloat&gt;(HEIGHT));
&nbsp;&nbsp;&nbsp;&nbsp;shader.Use();
&nbsp;&nbsp;&nbsp;&nbsp;glUniformMatrix4fv(glGetUniformLocation(shader.getProgram(),&nbsp;"projection"),&nbsp;1,&nbsp;GL_FALSE,&nbsp;glm::value_ptr(projection));
&nbsp;&nbsp;&nbsp;&nbsp;FT_Library&nbsp;ft;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FT_Init_FreeType(&amp;ft))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"ERROR::FREETYPE:&nbsp;Could&nbsp;not&nbsp;init&nbsp;FreeType&nbsp;Library"&nbsp;&lt;&lt;&nbsp;std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;FT_Face&nbsp;face;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FT_New_Face(ft,&nbsp;"fonts/FZSTK.TTF",&nbsp;0,&nbsp;&amp;face))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"ERROR::FREETYPE:&nbsp;Failed&nbsp;to&nbsp;load&nbsp;font"&nbsp;&lt;&lt;&nbsp;std::endl;
if&nbsp;(FT_Select_Charmap(face,&nbsp;ft_encoding_unicode))
&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"ERROR::FT_Select_Charmap"&nbsp;&lt;&lt;&nbsp;std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;FT_Set_Pixel_Sizes(face,&nbsp;0,&nbsp;48);
&nbsp;&nbsp;&nbsp;&nbsp;glPixelStorei(GL_UNPACK_ALIGNMENT,&nbsp;1);
int&nbsp;charUnicode&nbsp;=&nbsp;0x6211;
int&nbsp;index&nbsp;=&nbsp;&nbsp;FT_Get_Char_Index(face,charUnicode);
FT_Load_Glyph(face,index,&nbsp;FT_LOAD_RENDER);
GLuint&nbsp;texture;
glGenTextures(1,&nbsp;&amp;texture);
glBindTexture(GL_TEXTURE_2D,&nbsp;texture);
glTexImage2D(
&nbsp;&nbsp;&nbsp;&nbsp;GL_TEXTURE_2D,
&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.width,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.rows,
&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;GL_UNSIGNED_BYTE,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.buffer
);
glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_S,&nbsp;GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_T,&nbsp;GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MIN_FILTER,&nbsp;GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MAG_FILTER,&nbsp;GL_LINEAR);
Character&nbsp;character&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;texture,
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap.width,&nbsp;face-&gt;glyph-&gt;bitmap.rows),
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap_left,&nbsp;face-&gt;glyph-&gt;bitmap_top),
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;advance.x
};
Characters.insert(std::pair&lt;GLshort,&nbsp;Character&gt;(charUnicode,&nbsp;character));
charUnicode&nbsp;=&nbsp;21644;
index&nbsp;=&nbsp;&nbsp;FT_Get_Char_Index(face,charUnicode);
FT_Load_Glyph(face,index,&nbsp;FT_LOAD_RENDER);
glGenTextures(1,&nbsp;&amp;texture);
glBindTexture(GL_TEXTURE_2D,&nbsp;texture);
glTexImage2D(
&nbsp;&nbsp;&nbsp;&nbsp;GL_TEXTURE_2D,
&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.width,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.rows,
&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;GL_UNSIGNED_BYTE,
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.buffer
);
&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_S,&nbsp;GL_CLAMP_TO_EDGE);
&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_T,&nbsp;GL_CLAMP_TO_EDGE);
&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MIN_FILTER,&nbsp;GL_LINEAR);
&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MAG_FILTER,&nbsp;GL_LINEAR);
Character&nbsp;character1&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;texture,
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap.width,&nbsp;face-&gt;glyph-&gt;bitmap.rows),
&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap_left,&nbsp;face-&gt;glyph-&gt;bitmap_top),
&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;advance.x
};
Characters.insert(std::pair&lt;GLshort,&nbsp;Character&gt;(charUnicode,&nbsp;character1));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(GLubyte&nbsp;c&nbsp;=&nbsp;0;&nbsp;c&nbsp;&lt;&nbsp;128;&nbsp;c++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FT_Load_Char(face,&nbsp;c,&nbsp;FT_LOAD_RENDER))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"ERROR::FREETYTPE:&nbsp;Failed&nbsp;to&nbsp;load&nbsp;Glyph"&nbsp;&lt;&lt;&nbsp;std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLuint&nbsp;texture;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glGenTextures(1,&nbsp;&amp;texture);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D,&nbsp;texture);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glTexImage2D(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_TEXTURE_2D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.width,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.rows,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_RED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_UNSIGNED_BYTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;bitmap.buffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_S,&nbsp;GL_CLAMP_TO_EDGE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_WRAP_T,&nbsp;GL_CLAMP_TO_EDGE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MIN_FILTER,&nbsp;GL_LINEAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glTexParameteri(GL_TEXTURE_2D,&nbsp;GL_TEXTURE_MAG_FILTER,&nbsp;GL_LINEAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Character&nbsp;character&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;texture,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap.width,&nbsp;face-&gt;glyph-&gt;bitmap.rows),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glm::ivec2(face-&gt;glyph-&gt;bitmap_left,&nbsp;face-&gt;glyph-&gt;bitmap_top),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;glyph-&gt;advance.x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Characters.insert(std::pair&lt;GLshort,&nbsp;Character&gt;(c,&nbsp;character));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;FT_Done_Face(face);
&nbsp;&nbsp;&nbsp;&nbsp;FT_Done_FreeType(ft);
&nbsp;&nbsp;&nbsp;&nbsp;glGenVertexArrays(1,&nbsp;&amp;VAO);
&nbsp;&nbsp;&nbsp;&nbsp;glGenBuffers(1,&nbsp;&amp;VBO);
&nbsp;&nbsp;&nbsp;&nbsp;glBindVertexArray(VAO);
&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER,&nbsp;VBO);
&nbsp;&nbsp;&nbsp;&nbsp;glBufferData(GL_ARRAY_BUFFER,&nbsp;sizeof(GLfloat)&nbsp;*&nbsp;6&nbsp;*&nbsp;4,&nbsp;NULL,&nbsp;GL_DYNAMIC_DRAW);
&nbsp;&nbsp;&nbsp;&nbsp;glEnableVertexAttribArray(0);
&nbsp;&nbsp;&nbsp;&nbsp;glVertexAttribPointer(0,&nbsp;4,&nbsp;GL_FLOAT,&nbsp;GL_FALSE,&nbsp;4&nbsp;*&nbsp;sizeof(GLfloat),&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;glBindVertexArray(0);
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!glfwWindowShouldClose(window))
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfwPollEvents();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glClearColor(0.2f,&nbsp;0.3f,&nbsp;0.3f,&nbsp;1.0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RenderText(shader,&nbsp;"我This&nbsp;和eeis&nbsp;sample&nbsp;text",&nbsp;25.0f,&nbsp;25.0f,&nbsp;1.0f,&nbsp;glm::vec3(0.5,&nbsp;0.8f,&nbsp;0.2f));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RenderText(shader,&nbsp;"(C)&nbsp;LearnOpenGL.com",&nbsp;540.0f,&nbsp;570.0f,&nbsp;0.5f,&nbsp;glm::vec3(0.3,&nbsp;0.7f,&nbsp;0.9f));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfwSwapBuffers(window);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
void&nbsp;RenderText(Shader&nbsp;&amp;shader,&nbsp;const&nbsp;QString&amp;&nbsp;text,&nbsp;GLfloat&nbsp;x,&nbsp;GLfloat&nbsp;y,&nbsp;GLfloat&nbsp;scale,&nbsp;glm::vec3&nbsp;color)
{
&nbsp;&nbsp;&nbsp;&nbsp;shader.Use();
&nbsp;&nbsp;&nbsp;&nbsp;glUniform3f(glGetUniformLocation(shader.getProgram(),&nbsp;"textColor"),&nbsp;color.x,&nbsp;color.y,&nbsp;color.z);
&nbsp;&nbsp;&nbsp;&nbsp;glActiveTexture(GL_TEXTURE0);
&nbsp;&nbsp;&nbsp;&nbsp;glBindVertexArray(VAO);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;nCount&nbsp;=&nbsp;text.count();
&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0&nbsp;;&nbsp;i&nbsp;&lt;&nbsp;nCount&nbsp;;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QChar&nbsp;cha&nbsp;=&nbsp;text.at(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ushort&nbsp;uni&nbsp;=&nbsp;cha.unicode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Character&nbsp;ch;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(uni&nbsp;&gt;=&nbsp;0x4E00&nbsp;&amp;&amp;&nbsp;uni&nbsp;&lt;=&nbsp;0x9FA5)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Characters.find(uni)!=Characters.end())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&lt;&lt;"unicode:"&lt;&lt;uni&lt;&lt;std::endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;Characters[uni];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat&nbsp;xpos&nbsp;=&nbsp;x&nbsp;+&nbsp;ch.Bearing.x&nbsp;*&nbsp;scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat&nbsp;ypos&nbsp;=&nbsp;y&nbsp;-&nbsp;(ch.Size.y&nbsp;-&nbsp;ch.Bearing.y)&nbsp;*&nbsp;scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat&nbsp;w&nbsp;=&nbsp;ch.Size.x&nbsp;*&nbsp;scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat&nbsp;h&nbsp;=&nbsp;ch.Size.y&nbsp;*&nbsp;scale;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GLfloat&nbsp;vertices[6][4]&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ypos&nbsp;+&nbsp;h,&nbsp;&nbsp;&nbsp;0.0,&nbsp;0.0&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ypos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,&nbsp;1.0&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos&nbsp;+&nbsp;w,&nbsp;ypos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,&nbsp;1.0&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ypos&nbsp;+&nbsp;h,&nbsp;&nbsp;&nbsp;0.0,&nbsp;0.0&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos&nbsp;+&nbsp;w,&nbsp;ypos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,&nbsp;1.0&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;xpos&nbsp;+&nbsp;w,&nbsp;ypos&nbsp;+&nbsp;h,&nbsp;&nbsp;&nbsp;1.0,&nbsp;0.0&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D,&nbsp;ch.TextureID);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER,&nbsp;VBO);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBufferSubData(GL_ARRAY_BUFFER,&nbsp;0,&nbsp;sizeof(vertices),&nbsp;vertices);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glBindBuffer(GL_ARRAY_BUFFER,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glDrawArrays(GL_TRIANGLES,&nbsp;0,&nbsp;6);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+=&nbsp;(ch.Advance&nbsp;&gt;&gt;&nbsp;6)&nbsp;*&nbsp;scale;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;glBindVertexArray(0);
&nbsp;&nbsp;&nbsp;&nbsp;glBindTexture(GL_TEXTURE_2D,&nbsp;0);
}</pre><p><br></p><p>参考：<a rel="nofollow" href="https://learnopengl-cn.readthedocs.io/zh/latest/06%20In%20Practice/02%20Text%20Rendering/">文字渲染</a><br>参考：<a rel="nofollow" href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering</a><br>参考：<a rel="nofollow" href="http://lazyfoo.net/tutorials/OpenGL/35_glsl_font/index.php">GLSL Font</a><br>参考：<a rel="nofollow" href="https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#FT_Load_Glyph">FreeType-2.9.1 API参考</a><br>参考：<a rel="nofollow" href="https://www.freetype.org/freetype2/docs/tutorial/step1.html">I. Simple Glyph Loading</a><br>参考：<a rel="nofollow" href="https://bbs.csdn.net/topics/390629916?page=1">eetype不能显示字母、数字、标点符号，可以显示汉字是怎么回事？ </a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/u014047672/article/details/71514487">OpenGL显示文字--显示汉字</a><br>参考：<a rel="nofollow" href="http://www.icodelogic.com/?p=210">OpenGL渲染绘制中文字符 </a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/t_w_s/article/details/16992203">opengl绘制汉字</a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/xuguangsoft/article/details/7982175">OpenGL显示字体</a><br>参考：<a rel="nofollow" href="http://www.cppblog.com/zmj/archive/2015/11/07/212209.html">OpenGL点阵字体绘制终极解决方案!哈!</a><br>参考：<a rel="nofollow" href="https://www.jianshu.com/p/bef7e25114f4">OpenGL 图形库的使用（四十六）—— 实战之文本渲染Text Rendering</a><br>参考：<a rel="nofollow" href="http://www.voidcn.com/article/p-qjsbizmx-bqa.html">OpenGL 绘制简单的英文字符</a><br>参考：<a rel="nofollow" href="https://github.com/wyj302/glProject/blob/master/Shader.h">glProject</a><br>参考：<a rel="nofollow" href="http://blog.linux.org.tw/~jserv/archives/002050.html">透過 FreeType 繪製 Unicode ASCII Art</a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/liqinghan/article/details/51901861">利用freetype显示unicode字符</a><br>参考：<a rel="nofollow" href="https://gist.github.com/er91/e4f8dd352ad6f01a8922">freetype_test.cpp</a><br>参考：<a rel="nofollow" href="https://gamedev.stackexchange.com/questions/81401/how-do-games-handle-rendering-asian-unicode-text">游戏如何处理渲染亚洲unicode文本？</a><br>参考：<a rel="nofollow" href="https://code.google.com/archive/p/freetype-gl/">freetype-gl</a><br>参考：<a rel="nofollow" href="http://www.voidcn.com/article/p-cjlpydbt-vn.html">利用freetype显示unicode字符</a><br>参考：<a rel="nofollow" href="https://yuanjinxiu.iteye.com/blog/1418985">第二人生的源码分析(五十八)使用FreeType字体</a><br>参考：<a rel="nofollow" href="https://github.com/Atmosphere-NX/Atmosphere/blob/master/stratosphere/fatal/source/fatal_font.cpp">fatal_font.cpp</a><br>参考：<a rel="nofollow" href="https://yiyu.iteye.com/blog/784949">OpenGL显示unicode编码的三维汉字的方法</a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/wdl20170204/article/details/70670486">Qt中获取字符串中的汉字</a><br>参考：<a rel="nofollow" href="https://stackoverflow.com/questions/15209494/problems-copying-freetype-bitmap-to-opengl-texture">将freetype位图复制到opengl纹理的问题</a><br>参考：<a rel="nofollow" href="http://chanae.walon.org/pub/ttf/ttf_glyphs.htm">Glyph Hell</a><br>参考：<a rel="nofollow" href="https://github.com/nigels-com/glew/issues/161">Problem with GLEW on Windows when building a static library within another project</a><br>参考：<a rel="nofollow" href="https://www.cnblogs.com/crsky/p/7261090.html">【OpenGL】使用FreeType库加载字体并在GL中绘制文字</a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/guoke312/article/details/79562920">freetype库实现文字显示</a><br>参考：<a rel="nofollow" href="https://blog.csdn.net/wudebao5220150/article/details/39299659">利用freetype显示中文字符</a><br>参考：<a rel="nofollow" href="https://www.cnblogs.com/ynxf/p/6274067.html">使用freetype来显示中文汉字和英文字符</a><br></p><p><br></p><p>第二阶段:</p><p>汉字那么多，康熙字典有3万印象中是这个数量级，常用汉字3000多，还有繁体简体的，怎么高效的渲染呢?</p><p>将所绘制的文字都放到一个较大的纹理上去，然后再纹理上做索引，当绘制的时候，去查表。在将纹理贴到网格上绘制出来.</p><p>表中可以先包含3000个常用字，然后没出现的动态注册添加到大纹理中去</p><p>参考:<a rel="nofollow" href="https://blog.csdn.net/qq_26280299/article/details/46741857">[置顶]OpenGL11-绘制汉字最高效方法(使用Freetype)（代码已更新）</a><br>参考:<a rel="nofollow" href="http://www.cnblogs.com/zhanglitong/p/3206497.html">OpenGL11-绘制汉字最高效方法(使用Freetype)（代码已更新）</a><br>参考:<a rel="nofollow" href="https://yq.aliyun.com/ziliao/569257">[置顶]OpenGL11-绘制汉字最高效方法(使用Freetype)（代码已更新）</a><br>参考:<a rel="nofollow" href="https://blog.csdn.net/wyx100/article/details/75579581">python+freetype+opencv 图片中文（汉字）显示 详细图文教程和项目完整源代码</a><br>参考:<a rel="nofollow" href="http://www.cppblog.com/liangairan/archive/2016/09/11/214270.html">FreeType使用的总结</a><br>参考:<a rel="nofollow" href="http://www.23book.net/SoftwareDev/VC/54899.htm">让irrlicht支持中文输入和输出</a><br>参考:<a rel="nofollow" href="http://dev.gameres.com/Program/Visual/3D/ogre/ttf.htm">让OGRE支持中文（二）</a><br>参考:<a rel="nofollow" href="https://tools.ietf.org/doc/libfreetype6/tutorial/step2.html">Step 2 — managing glyphs</a><br>参考:<a rel="nofollow" href="http://blog.51cto.com/general/324523">freetype2 中文显示</a><br>参考:<a rel="nofollow" href="http://mudream.logdown.com/posts/257996/in-opengl-rendering-of-text">在OpenGL繪製中文字</a><br>参考:<a rel="nofollow" href="https://my.oschina.net/u/3773235/blog/1612640">第二部分 管理字形</a><br>参考:<a rel="nofollow" href="http://bbs.100ask.org/thread-15894-1-1.html">freetype显示带有空格时，下一行的内容就不能显示了</a><br>参考:<a rel="nofollow" href="https://my.oschina.net/u/1414326/blog/279456">修改cocos2dx-3.0有些字体描边偏移的问题</a><br>参考:<a rel="nofollow" href="https://freetype-py.readthedocs.io/en/latest/ft_load_flags.html">FT_LOAD_FLAGS</a><br></p><p><br></p><h2>后记:</h2><p>打算让rtcw/quake系列的游戏也支持中文渲染，从上面的文章已经有了思路，可是还是想不好到底怎么修改，游戏渲染部分的代码还是要细细看明白才能找到正确的切入点；</p><p>网上看到ET支持unicode渲染，测试了一下</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/1545922434125476.png" title="1545922434125476.png" alt="image.png" class="localImage"></p><p>ET中的思路和原来ascii的渲染逻辑所以整体结构改变不是很大，但毕竟达到了效果 可以参考</p>
    </div>
    
    
    <p class="pc_current ask-tip">登录后可下载附件，请<a href="https://auth.huaweicloud.com/authui/login?service=https://bbs.huaweicloud.com/blogs/104398#attachment&amp;locale=zh-cn">登录</a>或者<a href="https://reg.huaweicloud.com/registerui/public/custom/register.html?locale=zh-cn&amp;service=https://bbs.huaweicloud.com#/register">注册</a></p>

    <!-- 版权声明 start -->
    
   
    
    <!-- 版权声明 end -->

    <div class="blog-menu-footer m-blog-menu-footer-bottom">
        
    </div>
</div></div>