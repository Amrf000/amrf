<link rel="stylesheet" type="text/css" href="../css/blog.css"><div class="cloud-blog-detail-content-wrap the_height"><div class="cloud-blog-detail-content-wrap">
    <div class="cloud-blog-detail-content blog-content-block-0" id="blogContent">
        <h3>相关文案:</h3><p><a rel="nofollow" href="https://docs.spring.io/spring/docs/2.5.x/reference/aop.html">https://docs.spring.io/spring/docs/2.5.x/reference/aop.html</a></p><p><a rel="nofollow" href="https://blog.csdn.net/AlbenXie/article/details/72783744">https://blog.csdn.net/AlbenXie/article/details/72783744</a></p><p><a rel="nofollow" href="https://blog.csdn.net/baidu_33403616/article/details/70304051">https://blog.csdn.net/baidu_33403616/article/details/70304051</a></p><p><a rel="nofollow" href="http://haidaoqi3630.iteye.com/blog/2172845">http://haidaoqi3630.iteye.com/blog/2172845</a></p><h3><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">AOP相关概念&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">方面（Aspect）：</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">连接点（Joinpoint）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">通知（Advice）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">切入点（Pointcut）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">引入（Introduction）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">目标对象（Target Object）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: 包含连接点的对象。也被称作被通知或被代理对象。POJO&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);color:#FF0000;">AOP代理（AOP Proxy）</span><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。&nbsp;</span><br><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;background-color:rgb(255,255,255);">织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。&nbsp;</span></h3><p><br></p><table><thead><tr class="firstRow"><th>通知类型</th><th>简介</th></tr></thead><tbody><tr><td>Before（前置通知）</td><td>目标方法调用之前执行</td></tr><tr><td>After（后置通知）</td><td>目标方法调用之后执行</td></tr><tr><td>After-returning（返回通知）</td><td>目标方法执行成功后执行</td></tr><tr><td>After-throwing（异常通知）</td><td>目标方法抛出异常后执行</td></tr><tr><td>Around（环绕通知）</td><td>相当于合并了前置和后置<br><br></td></tr></tbody></table><h3>引申文案 ：</h3><p><a rel="nofollow" href="https://blog.csdn.net/eson_15/article/details/51090040">谈谈Spring中的IOC和AOP概念</a></p><p>IOC（Inverse of Control）：控制反转，也可以称为依赖倒置。--依赖注入</p><p>2.5.x特性参考</p><p><a rel="nofollow" href="https://docs.spring.io/spring/docs/2.5.x/reference/">https://docs.spring.io/spring/docs/2.5.x/reference/</a></p><p><br></p><p><a rel="nofollow" class="tooltipped tooltipped-s css-truncate" href="https://gist.github.com/dchjmichael/07dfd189c4c29bab63ec#file-spring-schema-md" style="background-color:rgb(250,251,252);color:rgb(3,102,214);font-family:'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;font-size:12px;white-space:normal;"><span class="user-select-contain gist-blob-name css-truncate-target" style="font-weight:600;display:inline-block;overflow:hidden;vertical-align:top;">Spring Schema</span></a></p><p><a rel="nofollow" href="https://gist.github.com/dchjmichael/07dfd189c4c29bab63ec">https://gist.github.com/dchjmichael/07dfd189c4c29bab63ec</a> </p><p><a rel="nofollow" href="https://www.jianshu.com/p/8639e5e9fba6">https://www.jianshu.com/p/8639e5e9fba6</a> </p><p><a rel="nofollow" href="https://blog.csdn.net/fanxiaobin577328725/article/details/68921567">https://blog.csdn.net/fanxiaobin577328725/article/details/68921567</a> </p><p><br></p>
    </div>
    
    
    <p class="pc_current ask-tip">登录后可下载附件，请<a href="https://auth.huaweicloud.com/authui/login?service=https://bbs.huaweicloud.com/blogs/110268#attachment&amp;locale=zh-cn">登录</a>或者<a href="https://reg.huaweicloud.com/registerui/public/custom/register.html?locale=zh-cn&amp;service=https://bbs.huaweicloud.com#/register">注册</a></p>

    <!-- 版权声明 start -->
    
   
    
    <!-- 版权声明 end -->

    <div class="blog-menu-footer m-blog-menu-footer-bottom">
        
    </div>
</div></div>