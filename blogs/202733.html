<link rel="stylesheet" type="text/css" href="../css/blog.css"><div class="cloud-blog-detail-content-wrap the_height"><div class="cloud-blog-detail-content-wrap">
    <div class="cloud-blog-detail-content blog-content-block-0" id="blogContent">
        <p style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">原文:<a target="_self">Java CyclicBarrier与CountDownLatch</a></span></p>
<h2 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">1.简介</span></h2>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">在本教程中，我们将比较&nbsp;</span><em>CyclicBarrier</em><span style="">&nbsp;和&nbsp;</span><em>CountDownLatch</em><span style="">并尝试了解两者之间的异同。</span></p>
<h2 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">2.这些是什么？</span></h2>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">当涉及到并发时，将每个对象要完成的概念概念化可能是一个挑战。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style=""><br></span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">首先，</span><strong><em><span style=""><span style="">CountDownLatch</span></span></em><span style=""><span style="">和</span></span><em><span style=""><span style="">CyclicBarrier</span></span></em><span style=""><span style="">都用于管理多线程应用程序</span></span></strong><span style="">。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">而且，</span><strong>它们都旨在表示给定线程或线程组应如何等待。</strong></p>
<h3 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">2.1。&nbsp;</span><em>CountDownLatch（自减门<em style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;">闩</em>）</em></h3>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">一个&nbsp;</span><em>CountDownLatch</em><span style="">&nbsp;是一个结构，一个线程</span><em>等待</em><span style="">其他线程&nbsp;</span><span style=""><em style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;">倒计时<span style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium;">门闩</span></em>直至为零。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style=""><span style="">我们可以将其想象为正在准备的餐厅的一道菜。</span><span style="">无论由哪个厨师准备&nbsp;</span></span><em>n种&nbsp;</em><span style="">食物，服务员都必须</span><em>等到</em><span style=""><span style="">所有食物都放在盘子上。</span><span style="">如果一个盘子可&nbsp;</span><span style="">容纳</span></span><em>n个&nbsp;</em><span style=""><span style="">物品，那么任何厨师都会&nbsp;</span><span style="">在他放在盘子上的一个物品的同时对</span></span><em style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;">倒计时门闩减一操作</em><span style="">。</span></p>
<h3 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">2.2。&nbsp;CyclicBarrier（</span><em>循环阻障）</em></h3>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">甲&nbsp;</span><em>的CyclicBarrier&nbsp;</em><span style="">是可重复使用的构建体，其中一组线程</span><em>等待</em><span style="">在一起，直到所有线程&nbsp;</span><em>到达</em><span style=""><span style="">。</span><span style="">在这一点上，所述屏障破裂，一个&nbsp;</span></span><em>动作</em><span style="">可任选地服用。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style=""><span style="">我们可以将其视为一群朋友。</span><span style="">每当他们计划在餐厅用餐时，他们都会决定可以见面的共同点。</span><span style="">他们</span><span style="">在那儿</span></span><em>等着&nbsp;</em><span style="">，只有每个人</span><em>到了</em><span style="">，他们才能一起去餐厅吃饭。</span></p>
<h3 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style=""><span style="">2.3。</span><span style="">进一步阅读</span></span></h3>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">有关每个单独组件的更多详细信息，请分别参考我们之前关于</span><em><a style="color: rgb(99, 177, 117);"><span style="">CountDownLatch</span></a></em><span style="">&nbsp;和</span><em><a style="color: rgb(99, 177, 117);"><span style="">CyclicBarrier的</span></a></em><span style=""><span style="">教程&nbsp;</span><span style="">&nbsp;。</span></span></p>
<h2 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">3.任务与线程</span></h2>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">让我们更深入地研究这两个类之间的一些语义差异。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">如定义中所述，</span><em>CyclicBarrier</em><span style="">允许多个线程互相等待，而</span><em>CountDownLatch</em><span style="">允许一个或多个线程等待许多任务完成。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">简而言之，</span><span style="color: rgb(255, 0, 0);"><strong><em>CyclicBarrier</em>维护<em>线程</em></strong><strong>数</strong></span><span style=""><strong><span style="">，</span></strong></span><span style="color: rgb(255, 0, 0);">而<strong><em>CountDownLatch</em>维护<em>任务数</em></strong></span><span style="">。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style=""><span style="">在下面的代码中，我们定义了</span><span style="">一个计数为2</span><span style="">的</span></span><em>CountDownLatch</em><span style=""><span style="">。</span><span style="">接下来，我们</span><span style="">从单个线程两次</span><span style="">调用&nbsp;</span></span><em>countDown（）</em><span style="">：</span></p>
<pre>CountDownLatch&nbsp;countDownLatch&nbsp;=&nbsp;new&nbsp;CountDownLatch(2);
Thread&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread(()&nbsp;-&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;countDownLatch.countDown();
&nbsp;&nbsp;&nbsp;&nbsp;countDownLatch.countDown();
});
t.start();
countDownLatch.await();

assertEquals(0,&nbsp;countDownLatch.getCount());</pre>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">一旦锁存器达到零，</span><em>等待&nbsp;</em><span style=""><span style="">调用就会</span><span style="">返回。</span></span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">请注意，在这种情况下，</span><strong>我们能够使同一线程将计数减少两次。</strong></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><strong><span style=""><span style="">但是，</span><em><span style="">CyclicBarrier</span></em><span style="">在这一点上有所不同。</span></span></strong></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">与上面的示例类似，我们创建一个</span><em>CyclicBarrier，</em><span style=""><span style="">它的计数再次为2，并</span><span style="">在同一线程上</span><span style="">调用</span></span><em>await（）两次</em><span style="">：</span></p>
<pre>CyclicBarrier&nbsp;cyclicBarrier&nbsp;=&nbsp;new&nbsp;CyclicBarrier(2);
Thread&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread(()&nbsp;-&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyclicBarrier.await();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyclicBarrier.await();&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;|&nbsp;BrokenBarrierException&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;error&nbsp;handling
&nbsp;&nbsp;&nbsp;&nbsp;}
});
t.start();

assertEquals(1,&nbsp;cyclicBarrier.getNumberWaiting());
assertFalse(cyclicBarrier.isBroken());</pre>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">这里的第一个区别是正在等待的线程就是barrier（障碍）<span style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium;">本身</span>。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">其次，更重要的是，</span><strong><span style=""><span style="">第二个</span></span><em><span style=""><span style="">await（）</span></span></em><span style=""><span style="">&nbsp;是无用的</span></span></strong><span style="">。</span><strong><span style=""><span style="">单个线程无法对Barrier（<strong style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;">障碍）做<strong style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;">两次</strong></strong>自减</span></span><span style=""><span style="">。</span></span></strong></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">确实，因为&nbsp;</span><em>t</em><span style="">必须&nbsp;</span><em>等待</em><span style="">另一个线程调用&nbsp;</span><em>await（）</em><span style="">&nbsp;才能使计数增加到2，所以</span><em>t</em><span style="">的第二次对</span><em>await（）的&nbsp;</em><span style="">调用实际上不会被调用，直到屏障已经被打破！</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">在我们的测试中，</span><strong>没有越过障碍，因为我们只有一个线程在等待，而没有两个线程将使障碍被触发。</strong><span style="">从</span><em>CyclicBarrier.isBroken（）</em><span style=""><span style="">方法</span><span style="">也很明显，该</span><span style="">方法返回</span></span><em>false</em><span style="">。</span></p>
<h2 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">4.可重用性</span></h2>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style=""><span style="">这两个类别之间第二个最明显的区别是可重用性。</span><span style="">详细地说，</span></span><strong><span style=""><span style="">当屏障在</span></span><em><span style=""><span style="">CyclicBarrier中</span></span></em><span style=""><span style="">跳闸时&nbsp;</span><span style="">，计数将重置为其原始值。</span></span></strong>&nbsp;<strong><em><span style=""><span style="">CountDownLatch</span></span></em><span style=""><span style="">是不同的，因为计数永远不会重置。</span></span></strong></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">在给定的代码中，我们定义了一个</span><em>CountCount</em><span style=""><span style="">为7</span><span style="">的</span><em><span style="">CountDownLatch</span></em><span style="">，并通过20个不同的调用对其进行计数：</span></span></p>
<pre>CountDownLatch&nbsp;countDownLatch&nbsp;=&nbsp;new&nbsp;CountDownLatch(7);
ExecutorService&nbsp;es&nbsp;=&nbsp;Executors.newFixedThreadPool(20);
for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;es.execute(()&nbsp;-&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;prevValue&nbsp;=&nbsp;countDownLatch.getCount();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countDownLatch.countDown();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(countDownLatch.getCount()&nbsp;!=&nbsp;prevValue)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputScraper.add("Count&nbsp;Updated");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;
}&nbsp;
es.shutdown();

assertTrue(outputScraper.size()&nbsp;&lt;=&nbsp;7);</pre>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">我们观察到，即使有20个不同的线程调用&nbsp;</span><em>countDown（）</em><span style="">，计数一旦达到零也不会重置。</span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">与上面的示例类似，我们定义一个</span><em>Countic</em><span style=""><span style="">&nbsp;7</span><span style="">的</span><em><span style="">CyclicBarrier&nbsp;</span></em><span style="">并从20个不同的线程中等待它：</span></span></p>
<pre>CyclicBarrier&nbsp;cyclicBarrier&nbsp;=&nbsp;new&nbsp;CyclicBarrier(7);

ExecutorService&nbsp;es&nbsp;=&nbsp;Executors.newFixedThreadPool(20);
for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;es.execute(()&nbsp;-&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cyclicBarrier.getNumberWaiting()&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputScraper.add("Count&nbsp;Updated");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyclicBarrier.await();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;|&nbsp;BrokenBarrierException&nbsp;e)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;error&nbsp;handling
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;});
}
es.shutdown();

assertTrue(outputScraper.size()&nbsp;&gt;&nbsp;7);</pre>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">在这种情况下，我们观察到每次运行新线程时该值都会减小，一旦达到零，就会重置为原始值。</span></p>
<h2 style="font-family: &quot;Microsoft YaHei&quot;; white-space: normal;"><span style="">5.结论</span></h2>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">总而言之，&nbsp;&nbsp;</span><em>CyclicBarrier</em><span style="">和</span><em><span style=""><span style="">CountDownLatch</span></span><strong>&nbsp;</strong></em><span style=""><span style="">都是在多个线程之间进行同步的有用工具。</span><span style="">但是，它们在功能上根本不同。</span><span style="">在确定最适合该工作时，请仔细考虑每个因素。</span></span></p>
<p style="font-family: &quot;Microsoft YaHei&quot;; font-size: medium; white-space: normal;"><span style="">像往常一样，所有讨论的示例都可以</span><a rel="nofollow" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-concurrency-advanced-2" style="color: rgb(99, 177, 117);"><span style="">在Github</span></a><span style=""><span style="">上访问</span><span style="">。</span></span></p>
<p><br></p>
<p>其他相关讨论：</p>
<p><a target="_self">Java concurrency: Countdown latch vs Cyclic barrier</a></p>
<p><br></p>
<p><a target="_self">CountDownLatch与CyclicBarrier</a> </p>
<p><br></p>
    </div>
    
    
    <p class="pc_current ask-tip">登录后可下载附件，请<a href="https://auth.huaweicloud.com/authui/login?service=https://bbs.huaweicloud.com/blogs/202733#attachment&amp;locale=zh-cn">登录</a>或者<a href="https://reg.huaweicloud.com/registerui/public/custom/register.html?locale=zh-cn&amp;service=https://bbs.huaweicloud.com#/register">注册</a></p>

    <!-- 版权声明 start -->
    
    
    
    <!-- 版权声明 end -->

    <div class="blog-menu-footer m-blog-menu-footer-bottom">
        
        <a class="common-blog-menu-btn title_banner_7" target="_self" rel="noopener noreferrer" mate_data_ts="bbs_blogdetail_blogTag.click.Java_Blog" title="Java" href="https://developer.huaweicloud.com/tags/200077/blog_1">Java</a>
        
    </div>
</div></div>