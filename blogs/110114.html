<link rel="stylesheet" type="text/css" href="../css/blog.css"><div class="cloud-blog-detail-content-wrap the_height"><div class="cloud-blog-detail-content-wrap">
    <div class="cloud-blog-detail-content blog-content-block-0" id="blogContent">
        <p>以vs2015举例:<br></p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>找到C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\Remote Debugger\目录;</p></li><li><p>根据编译程序是32位的还是64位的选择，Remote Debugger目录下的x86或者x64,拷贝到目标远程机器中;</p></li><li><p>在目标远程主机上启动msvsmon.exe程序;</p></li><li><p>为了连接方便,在msvsmon.exe中点击工具选项设置如下:</p><p><img src="https://bbs.huaweicloud.com/static/ueditor/themes/default/images/spacer.gif" alt="spacer.gif" class="new-carousel" title="://bbs.huaweicloud.com/static/ueditor/themes/default/images/spacer.gif"><img src="https://bbs-img.huaweicloud.com/blogs/img/1550149205879328.png" class="new-carousel" title="://bbs-img.huaweicloud.com/blogs/img/1550149205879328.png"></p></li><li><p>在调试机器上打开项目并选择调试附加到进程,输入目标机器的ip:4200，回车确定;</p></li><li><p>&nbsp;将项目编译好的程序拷贝到目标远程机器, 在目标机器上启动程序;</p></li><li><p>在调试机器上的vs附加到进程窗口下方点击刷新附加,选择目标调试进程名进行调试;</p><p><br></p><p><br></p><p><br></p></li></ol><p><br></p><p>一个小技巧，如果目标程序的问题是过于早的自动退出，有没有崩溃信息和报错，也就是程序存在了几秒导致难以附加，可以考虑在程序入口加上一段时间延时，以便于附加成功;</p><p><br></p><p>&nbsp;参考文档:</p><p><a rel="nofollow" href="https://www.cnblogs.com/sundajade/articles/5440334.html">https://www.cnblogs.com/sundajade/articles/5440334.html</a> </p><p><a rel="nofollow" href="https://www.cnblogs.com/tuyile006/p/7827158.html">https://www.cnblogs.com/tuyile006/p/7827158.html</a> </p><p><a rel="nofollow" href="https://blog.csdn.net/u011014707/article/details/15498129">https://blog.csdn.net/u011014707/article/details/15498129</a> </p><p><a rel="nofollow" href="https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&amp;l=ZH-CN&amp;k=k(vs.debug.remote.overview)&amp;rd=true">https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&amp;l=ZH-CN&amp;k=k(vs.debug.remote.overview)&amp;rd=true</a> </p><p><a rel="nofollow" href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/remote-debugging?view=vs-2017">https://docs.microsoft.com/zh-cn/visualstudio/debugger/remote-debugging?view=vs-2017</a> </p><p>/********************************************************************************/</p><p>https://github.com/thawk/wiki/wiki/windbg</p><p>如何将64位Dump转成32位 (https://www.cnblogs.com/alone-striver/p/7661269.html)</p><p>.load wow64exts&nbsp;</p><p>!sw</p><p>分析Dump</p><p>!analyze -v</p><p>~* kv</p><p>https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-analyze</p><p>https://blog.51cto.com/whatday/1382378</p><p>https://blog.csdn.net/china_jeffery/article/details/79317864</p><p>下载系统文件的符号(https://www.cnblogs.com/Fido/archive/2011/12/26/2302377.html)</p><p>symchk c:\winnt\system32\ntoskrnl.exe /r /s srv*d:\symbols*http://msdl.microsoft.com/download/symbols</p><p>查看堆栈</p><p>kn [frame count]察看当前堆栈及其索引, frame count指定要显示多少桢</p><p>kb显示堆栈桢地址，返回地址，参数，函数名等</p><p>kv在kb的基础上增加了函数调用约定等信息， 所以推荐用kv命令察看堆栈.</p><p>.frame [frame index] 将当前堆栈切换到某个堆栈桢, 比如.frame 1 切换到第1桢</p><p>dv 命令察看当前堆栈桢的局部变量&nbsp;</p><p>堆栈桢的含义(https://www.cnblogs.com/qinfengxiaoyue/p/3399537.html)</p><p>显示当前调用栈信息</p><p>k</p><p>kv</p><p>.frame</p><p>!*kb</p><p>dps esp</p><p>dps esp l 100</p><p>查看当前局部变量</p><p>dv</p><p>(按下Ctrl+Alt+V)</p><p>Verbose mode ON.</p><p>0:000&gt; dv</p><p>上下文</p><p>可以通过.frame [index] 切换当前堆栈桢，然后通过dv 显示当前堆栈桢函数的局部变量（堆栈桢的index从0开始，可以通过kn命令显示堆栈桢索引）</p><p>查看线程死锁</p><p>!locks 显示死锁</p><p>!handle 列出当前进程所handle</p><p>!handle [index] f, 显示某个handle的详细信息</p><p>查看进程PEB</p><p>首先使用!peb获取内存中地址，然后使用 dt peb 内存地址 方式查看对应的数值</p><p>!peb</p><p>dt _peb addr</p><p>查看进程TEB</p><p>!teb</p><p>查看LastError值</p><p>!gle</p><p>!error</p><p>指定形式输出</p><p>? 0xxxxx+0n10</p><p>0x/0n/0t/0y 分别表示 16/10/8/2 进制。</p><p>格式化输出</p><p>.formats @eax</p><p>加载DLL时中断</p><p>sxe ld</p><p>sx, sxd, sxe, sxi, sxn, sxr 几条命令可用来设置异常和事件的处理方式。</p><p>显示地址附近结构</p><p>ln xxxx</p><p>显示加载模块</p><p>&nbsp;lm</p><p>&nbsp;列举当前进程线程信息</p><p>&nbsp;~</p><p>&nbsp;~*</p><p>&nbsp;显示/修改寄存器值</p><p>r</p><p>r eax</p><p>r eax=xxxxx</p><p>r eax</p><p>搜索全局变量/函数地址</p><p>x Kernel32!*</p><p>!handle</p><p>!handle c f</p><p>反汇编</p><p>u</p><p>u*反汇编</p><p>修改反汇编指令</p><p>u xxxx</p><p>a xxxx</p><p>u xxxx</p><p>&nbsp;断点相关</p><p>&nbsp;bp、bl、bc、bd、be</p><p>ba：内存访问断点</p><p>查看/修改内存</p><p>dd esp+8</p><p>d*查看，e*修改，可F1查看帮助。</p><p>踩内存问题定位总结</p><p>https://blog.csdn.net/helloguoqijun/article/details/78036096</p><p>Gflags工具是微软公司开发的windbg调试工具里自带的内存非法访问检查工具，简单易用。</p><p>Gflags的原理:</p><p>当分配一块内存时，通过调整内存块的分配位置，使其结尾恰好与系统分页边界对齐，然后在边界处再多分配一个不可访问的页作为保护区域。这样，一旦出现内存读/写越界时，进程就会Crash，从而帮助及时检查内存越界。</p><p>内存非法访问分类:</p><p>(1)数组访问越界</p><p>(2)释放过的指针继续访问</p><p>(3)重复释放指针</p><p>能使用list,就不要使用vector，避免连续内存分配失败</p><p>窗口Create必须要判断返回结果</p><p>new失败会抛出异常，而不是返回NULL,需要加std::nothrow异常说明</p><p>利用Vs为X86程序开启大内存的方法 (https://www.cnblogs.com/lidabo/p/12163101.html)</p><p>/********************************************************************************/</p><p>组播，伙伴地址，该请求在局域网内组播</p><p>p2p请求从该伙伴处下载</p><p>p2s方式从服务器</p><p>/********************************************************************************/</p>
    </div>
    
    
    <p class="pc_current ask-tip">登录后可下载附件，请<a href="https://auth.huaweicloud.com/authui/login?service=https://bbs.huaweicloud.com/blogs/110114#attachment&amp;locale=zh-cn">登录</a>或者<a href="https://reg.huaweicloud.com/registerui/public/custom/register.html?locale=zh-cn&amp;service=https://bbs.huaweicloud.com#/register">注册</a></p>

    <!-- 版权声明 start -->
    
   
    
    <!-- 版权声明 end -->

    <div class="blog-menu-footer m-blog-menu-footer-bottom">
        
        <a class="common-blog-menu-btn title_banner_7" target="_self" rel="noopener noreferrer" mate_data_ts="bbs_blogdetail_blogTag.click.Java_Blog" title="Java" href="https://developer.huaweicloud.com/tags/131877/blog_1">Java</a>
        
    </div>
</div></div>