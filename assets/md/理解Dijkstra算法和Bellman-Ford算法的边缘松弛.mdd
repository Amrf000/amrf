![理解Dijkstra算法和Bellman-Ford算法的边缘松弛](https://towardsdatascience.com/algorithm-shortest-paths-1d8fa3f50769)
理解Dijkstra算法和Bellman-Ford算法的边缘松弛
================================

[![Yasufumi TANIGUCHI](https://miro.medium.com/fit/c/48/48/1*DJgC5WgpMNqfVeru2NefzA.jpeg)](/@yasufumy?source=post_page-----1d8fa3f50769----------------------)

[Yasufumi TANIGUCHI](/@yasufumy?source=post_page-----1d8fa3f50769----------------------)

跟随

[6月18日](/algorithm-shortest-paths-1d8fa3f50769?source=post_page-----1d8fa3f50769----------------------) · 12 分钟阅读

![](https://miro.medium.com/max/30/1*bJAfxV4qB-R6ajA8GdSKQA.jpeg?q=20)

摄影：[Denys Nevozhai](https://unsplash.com/photos/7nrsVjvALnA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)，[来自Unsplash](https://unsplash.com/search/photos/intersection?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

**_最短路径问题_**的目的是找到从起始顶点到目标顶点的最短路径。我们广泛使用算法来解决从竞争性编程到Google Maps方向搜索的最短路径问题。通过理解关键概念“ **_边缘松弛_** ”，理解Dijsktra算法或Bellman-Ford算法的具体算法真的更容易。换句话说，如果不理解边缘松弛，可能很难将这些算法作为自己的算法。在这篇文章中，我专注于边缘松弛并解释一般结构来解决最短路径问题。此外，我们将通过简单的算法及其实现来更好地理解。我使用Python进行实现。这篇文章的结构如下：

1.  什么是最短路径问题？
2.  什么是边缘放松？
3.  放松的顺序
4.  DAG的最短路径及其实现

请注意，我们不会处理Dijkstra的算法或Bellman-ford算法。

1.什么是最短路径问题？
============

在这篇文章中，我解释了_最短路径问题中_的_单源最短路径问题_，其中我们需要找到从一个起始顶点到所有其他顶点的所有路径。我将最短路径定义为加权图中所有其他路径中从起始顶点到目标顶点的最小加权路径。在这里，您可以认为加权路径中的“加权”意味着达到目标顶点（某个顶点）的成本。从这里开始，当我说一个刚图时，它意味着一个加权图。

在下图中，让我们考虑从起始顶点S到其他顶点A和B的最短路径。

![](https://miro.medium.com/max/27/1*cQemI-nFIiLW2l6irfPZcg.png?q=20)

从顶点S到顶点A的最短路径变为“S→A”。在上图中，从顶点S到顶点A只有一条路径，因此我们不需要关心权重。另一方面，我们可以找到从顶点S到顶点B的两条路径，即“S→B”和“S→A→B”，最短路径变为“S→A→B”。在“S→B”中，路径的权重为3，但在“S→A→B”中，路径的权重变为2并且最短：1 + 1 = 2。我们可以认为最短路径的权重是从起始顶点到一个顶点的最短距离。

2.什么是边缘放松？
==========

在这里，我将解释重要和常用的概念，边缘松弛，以解决最短路径问题。通常，您可以通过使用边缘松弛来解决所有最短路径问题。边缘松弛是计算顶点到达的到达成本的操作。更具体地说，操作将变为：

对于从顶点_u_到顶点_v的边_，如果满足_d_ \[ _u_ \] + _w_（_u_，_v_）< _d_ \[ _v_ \]，则将_d_ \[ _v_ \] 更新为_d_ \[ _u_ \] + w（_u_，_v_）

顶点_u_和_v_代表图中的邻居，_d_ \[ _u_ \]和_d_ \[ _v_ \]分别代表顶点_u_和_v_的到达成本。此外，_w_（_u_，_v_）代表从顶点_u_到顶点_v_的边的权重。总结一下到目前为止，我们可以在下面做出这个数字。

![](https://miro.medium.com/max/30/1*GuDzLpfpwY2_gZZRqkq9hg.png?q=20)

现在我们知道我们可以从起始顶点S到两个顶点到达顶点_u_，并且该路径花费_d_ \[ _u_ \]。此外，我们可以从起始顶点S到四个顶点到达顶点_v_，并且该路径花费_d_ \[ _v_ \]。

这里，当_d_ \[ _u_ \] + _w_（_u_，_v_）小于_d_ \[ _v_ \] 时，边缘弛豫更新_d_ \[ _v_ \]到_d_ \[ _u_ \] + _w_（_u_，_v_）。换句话说，它将到顶点_v_（_d_ \[ _v_ \]）的当前到达成本更新为较低到达成本（_d_ \[ _u_ \] + _w_（_u_，_v_））。更新成本的原因是通过顶点的路径_你_可以更短，因为通过顶点_u_的路径的到达成本将低于当前路径的成本。实际上，**最短路径问题的算法通过重复使用边缘松弛来解决问题**。

我将展示一个例子，我们可以通过重复使用边缘松弛来解决最短路径问题。让我们通过边缘松弛找到与之前相同的图形的最短路径。我假设起始顶点S并将边缘松弛应用于图形以获得到顶点A和B的最短路径。

![](https://miro.medium.com/max/27/1*cQemI-nFIiLW2l6irfPZcg.png?q=20)

为了应用边缘松弛，我们需要知道到达成本，但是在搜索之前无法知道它，因此我们将顶点A和B的到达成本初始化为无穷大（∞）。顶点的无穷大成本意味着我们无法到达该顶点。另一方面，从起始顶点到起始顶点的到达成本为零，因此我们将顶点S 的_d_值设置为0。

![](https://miro.medium.com/max/27/1*dpYOoLWbYFqM-LGdrURmSw.png?q=20)

我们首先选择并放宽从顶点S出来的边缘，然后从顶点A向外放出边缘。首先，我们将边缘松弛应用于边缘SA。

![](https://miro.medium.com/max/27/1*gGHqpFKShFF56QexTVyzEA.png?q=20)

边SA满足_d_ \[S\] + _w_（S，A）< _d_ \[A\]，我们将_d_ \[A\]设为_d_ \[S\] + _w_（S，A）= 1。这里，Π\[A\]代表在到达成本_d_ \[A\] 的路径中到达顶点A之前的顶点。在这种情况下，Π\[A\]是S.Π\[A\] = S表示到达成本_d_ \[A\]的路径总是使用子路径A←S。细节将在下面描述，但我们可以使用Π重建路径。

我们以同样的方式放松边缘SB。

![](https://miro.medium.com/max/28/1*VbqfnyADjV2a8Tpa9jYHAg.png?q=20)

边缘SB满足_d_ \[S\] + _w_（S，B）< _d_ \[B\]，因此我们将_d_ \[B\] 设置为_d_ \[S\] + _w_（S，B）= 3。对于_d_ \[B\]路径重建，我们将Π\[B\]设置为S.随后，我们放宽从顶点A出来的边缘AB。

![](https://miro.medium.com/max/30/1*36h8wSkaprZ_uQhqCxJeEw.png?q=20)

边AB满足_d_ \[A\] + _w_（A，B）< _d_ \[B\]，因此我们将_d_ \[B\]设为_d_ \[A\] + _w_（A，B）= 2。一旦我们更新了B 的_d_值，我们也将Π\[B\]更新为A.从上图中，您可以发现从顶点S到顶点A和B的最短距离等于到达成本_d_。我们无法更新_d_值，因此我们完成了边缘放松。

在这里，让我们确认我们可以通过使用Π\[A\] = S和Π\[B\] = A来重建最短路径。在上图中，我们将重建从顶点S到顶点B的最短路径作为示例。从Π\[B\] = A，我们可以知道我们应该在到达顶点B的路径中到达顶点B之前访问顶点A.从Π\[A\] = S，我们可以知道我们应该首先访问顶点S然后到达顶点A.顶点S是起始顶点，因此我们不能再向后遍历。通过反转我们到目前为止获得的顶点，我们可以得到从顶点S到顶点B的最短路径，“S→A→B”。通常，我们可以通过反向跟踪Π\[ _v_ \]，Π\[Π\[ _v_ \]\]，Π\[Π\[Π\[ _v_ \]\]\] 来重建顶点_v_的最短路径，并且反转所获得的顶点。

3.放松的顺序
=======

在之前的部分中，我们并不关心放松边缘的顺序，但我们应该如何决定顺序呢？或者我们真的关心它吗？似乎我们可以通过随机放松边缘来获得最短路径。但这不正确。在这里，我将解释为什么我们应该关心顺序以及如何选择放松的边缘。

说实话，如果你随机选择并放松边缘，就会存在计算效率的非常糟糕的情况。例如，让我们考虑下面的图表。我假设此图中的_d_值已经初始化。

![](https://miro.medium.com/max/30/1*2GuSH0Iq2SCQQ5_Arl8gHg.png?q=20)

首先，让我们从左到右放松直线边缘。

![](https://miro.medium.com/max/30/1*rsO3KadUtT0y5aalRBJdiw.png?q=20)

接下来，我们放松边缘EG。

![](https://miro.medium.com/max/30/1*AxHaKUi27yOPicszvAisIg.png?q=20)

然后，我们放松边缘CE。

![](https://miro.medium.com/max/30/1*S5xX7E7bXGhfqNHffBbS3w.png?q=20)

在这里，您可能会发现我们可以再次放松边缘EG。

![](https://miro.medium.com/max/30/1*FcfcM4RZaoczQDqebfF7rg.png?q=20)

此外，当我们放松边缘AC时，我们可以再次放松边缘CE和EG。因此，如果我们不注意订单，我们会一次又一次地放松同样的优势。在上面的例子中，如果我们从左到右放松它们，我们可以有效地放松边缘。但是，有太密集的图形可视化，如上例所示。因此，事先找到有效的订单似乎是不现实的。这就是我们应该关心轻松秩序的原因。

那么，我们应该如何选择和放松边缘。实际上，像Dijkstra算法或Bellman-Ford算法这样的最短路径算法为我们提供了轻松的顺序。这意味着**每个最短路径算法基本上重复边缘松弛并根据图形的性质**（正或负权重，DAG，......等）**设计放松顺序**。换句话说，我们应该通过观​​察图形的本质来寻找如何选择和放松边缘的方法。总之，每个最短路径算法都具有以下通用结构：

1.初始化图形中的_d_和Π2。  
以某种方式选择边缘（取决于算法）并放松它。

4\. DAG的最短路径及其实施
================

在之前的部分中，我说我们应该通过观​​察图的性质来选择边缘松弛的方式。在这里，我将用Python实现解释DAG（有向_无环图_）的简单和简单的最短路径算法。DAG是图形没有循环。在本节中，我将解释算法，因为您知道[拓扑顺序。](https://en.wikipedia.org/wiki/Topological_sorting)如果您不熟悉它，请查看我的文章：[了解深度优先搜索和Python拓扑排序？](https://medium.com/@yasufumy/algorithm-depth-first-search-76928c065692)

在DAG的最短路径算法中，我们可以通过选择和放宽拓扑顺序中的出边来获得最短路径。这是具体的算法如下：

1.将起始顶点的d值初始化为0，将其他顶点初始化为∞2   
。以拓扑顺序放宽出边缘

让我们看看算法是如何工作的。我展示了我初始化_d_ s和拓扑排序的图表，如下所示。我假设起始顶点是B.让我们尝试解决最短路径问题。

![](https://miro.medium.com/max/30/1*sq55VJ3jI05AFGLu7vulsA.png?q=20)

每个顶点都是拓扑排序的，所以我们只是从左到右放松出边缘。我们不能从最左边的顶点A放松出边缘，所以我们不更新_d_。

![](https://miro.medium.com/max/30/1*h72qMqYEzuYJIuzOo45HrA.png?q=20)

接下来，我们放松来自顶点B的外出边缘，即BC和BD。一旦我们松开边缘，我们就会更新Π。我们将Π\[C\]设为B，将Π\[D\]设为B.

![](https://miro.medium.com/max/30/1*fblGRkdZV2CKyvvhESRcGg.png?q=20)

然后，我们放松了顶点C的外出边缘。我们不能将外出边缘放宽到顶点D，所以我们只更新_d_ \[E\]和_d_ \[F\]。此外，我们将Π\[E\]更新为C，将Π\[F\]更新为C.

![](https://miro.medium.com/max/30/1*vCEPD3QEowJcw-yrl5xnng.png?q=20)

我们从顶点D更新外出边缘。我们只将_d_ \[E\]和Π\[E\]更新为D.

![](https://miro.medium.com/max/30/1*el9ZyILttGp5WlyNfkinBw.png?q=20)

我们从顶点E更新外出边缘。我们还将Π\[F\]更新为E.

![](https://miro.medium.com/max/30/1*AKKopE8hgIkB0hqrAXEwCA.png?q=20)

顶点F没有外出边缘。我们完成了边缘松弛。最后，我们获得如下最短距离：我们不检查它是否在这里工作，但我们可以从Π重建最短路径。

![](https://miro.medium.com/max/30/1*kEcthZBvXMws5h7yUPtZ_g.png?q=20)

随后，让我们在Python中使用DAG实现最短路径算法，以便更好地理解。实现如下：在该实现中，该代码解决了上述说明中使用的图上的最短路径问题。此代码评估_d_和Π以解决问题。我假设我们事先已经知道了拓扑顺序。

首先，让我们看一下图表及其权重的表达方式。在上面的代码中，图表实现如下：

graph = {'A'：\['B'，'C'\]，  
 'B'：\['C'，'D'\]，  
 'C'：\['D'，'E'，'F'\]，  
 ' D'：\['E'，'F'\]，  
 'E'：\['F'\]，  
 'F'：\[\]}   
weight = {（'A'，'B'）：5，（'A'， 'C'）：2，  
 （'B'，'C'）：2，（'B'，'D'）：6，  
 （'C'，'D'）：7，（'C'，'E '）：4，（'C'，'F'）：2，  
 （'D'，'E'）： -  1，（'D'，'F'）：1，  
 （'E'，'F' ）： -  2}

该图的对应图如下：

![](https://miro.medium.com/max/30/1*3aC_LZIdATv1zUxPUOb2jA.png?q=20)

例如，当我们查看顶点C时，_graph_ \['C'\]返回\['D'，'E'，'F'\]，它们是来自顶点C的可到达邻居。因此这些顶点构造了外出边缘从顶点C开始。另外，你发现_权重_ \[ _u_，_v_ \]对应边缘_uv_的权重。

接下来，让我们看一下_dag\_shortest\_path的_每一行的角色，以获得最短的路径。从2到4的行是初始化如下：将起始顶点的_d_设置为0，将其他顶点设置为∞。此外，这些行初始化Π以重建路径。

d = {v：图中v的INF}   
d \[s\] = 0   
pi = {s：无}

从9到12的线对应于边缘松弛。_代码中的d\_temp_ < _d_ \[ _v_ \]对应于边缘松弛条件下的_d_ \[ _u_ \] + _w_（_u_，_v_）< _d_ \[ _v_ \]。满足此条件时，它会更新_d_ \[ _v_ \]。一旦更新了_d_，它也会更新Π。

d\_temp = d \[u\] +权重\[u，v\]   
如果d\_temp <d \[v\]：  
 d \[v\] = d\_temp   
 pi \[v\] = u

代码将此过程重复到拓扑顺序中每个顶点的外出边缘。这个重复过程由两个for循环解决。该_torder_持有拓扑排序的顶点。此外，_图形_返回顶点以构造顶点的传出边。因此，我们通过将来自_torder_的顶点视为_u_并将_图形_ \[ _u_ \]视为_v来_获得边缘_uv_。

for tor in torder：  
 for v in graph \[u\]：  
 ＃relax（u，v）

这就是代码解释的全部内容。我们不检查结果，但您可以通过终端中的以下命令执行代码：您将发现可以正确获取_d_和Π。

curl -s [https://gist.githubusercontent.com/yasufumy/e6477c836baa85735f6019bc0b0c1460/raw/ee4885e5d21f009ee490038525887d8fcf80f8d8/dag\_shortest\_path.py](https://gist.githubusercontent.com/yasufumy/e6477c836baa85735f6019bc0b0c1460/raw/ee4885e5d21f009ee490038525887d8fcf80f8d8/dag_shortest_path.py) | python3

最后，让我们考虑一下这个算法的时间复杂度。在该算法中，有两个主要的计算部分。一个用于拓扑排序。另一种是边缘放松。在上面的代码中，我们不进行拓扑排序，但实际上，我们需要这样做。所以我们应该考虑到这一点。我们可以通过深度优先搜索进行拓扑排序，因此时间复杂度为_O_（| _V_ | + | _E_ |）。循环的数量仅影响边缘松弛的时间复杂度，因为循环中的过程在恒定时间内运行。_torder_的循环_次数_为| _V_ | 并且_图_ \[ _u_ \] 的循环数是| _Ë_|。因此边缘松弛的时间复杂度为_O_（| _V_ | + | _E_ |）。总之，算法的整个时间复杂度为_O_（| _V_ | + | _E_ |）。

在这篇文章中，我专注于边缘松弛并解释最短路径问题及其算法。当您了解边缘松弛时，您可以轻松了解Dijsktra的算法或Bellman-Ford算法。此外，您可以了解这些算法之间的区别。感谢您阅读我的文章。

参考
--

*   [麻省理工学院开放式课件网站6.006第15讲：单源最短路径问题](https://www.youtube.com/watch?v=Aa2sqUhIn-E)
*   [麻省理工学院开放式课件6.006复习15：最短路径](https://www.youtube.com/watch?v=mQSp6VmfakA)