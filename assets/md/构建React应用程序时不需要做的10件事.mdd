![构建React应用程序时不需要做的10件事](https://medium.com/better-programming/10-things-not-to-do-when-building-react-applications-bc26d4f38644)
#### 最重要的

反应应用程序的最佳实践
-----------

构建React应用程序时不需要做的10件事
=====================

根据我在生产中的经验，应该避免什么
-----------------

[

![jsmanifest](https://miro.medium.com/fit/c/48/48/2*CUfRP0Rzg_acoQX5JqkNOg.jpeg)

](/@jsmanifest?source=post_page-----bc26d4f38644----------------------)

[jsmanifest](/@jsmanifest?source=post_page-----bc26d4f38644----------------------)

跟随

[6月30日](/better-programming/10-things-not-to-do-when-building-react-applications-bc26d4f38644?source=post_page-----bc26d4f38644----------------------) · 8 分钟阅读

![](https://miro.medium.com/max/20/1*7-ckgPLQ0lcF7nYAbkGIaQ.jpeg?q=20)

![](https://miro.medium.com/max/1100/1*7-ckgPLQ0lcF7nYAbkGIaQ.jpeg)

来自[Pexels](https://www.pexels.com/photo/flat-screen-monitor-turned-on-in-office-2343475/)的[Alex Qian](https://www.pexels.com/photo/flat-screen-monitor-turned-on-in-office-2343475/) [拍摄](https://www.pexels.com/photo/flat-screen-monitor-turned-on-in-office-2343475/)

[React](https://reactjs.org/)是一个很受欢迎的开发工具，我相信React的粉丝们感觉很幸运能够用这么好的图书馆弄脏你的手。

不幸的是，生活中没有任何东西是完美的，React也不例外。React带有它自己的_陷阱_ - 如果你现在不处理它们，其中一些可能会成为你的应用程序的严重问题。

构建React应用程序时，以下是10件事情。

* * *

1.在自己的私人世界中花费太多时间
=================

![](https://miro.medium.com/max/20/0*I9KYeTIJGSFE4M06.jpg?q=20)

![](https://miro.medium.com/max/1100/0*I9KYeTIJGSFE4M06.jpg)

照片来自[Pexels](https://www.pexels.com/ru-ru/photo/2505333/)的[Bruno](https://www.pexels.com/ru-ru/photo/2505333/) [Thethe](https://www.pexels.com/ru-ru/photo/2505333/)

如果您花费太多时间编写代码而没有花时间阅读社区中发生的事情，那么您可能会遇到社区中报告的错误编码实践。你可能最终使用那些糟糕的编码实践代码20次，然后你终于在Medium帖子中发现它们是坏的。

当发生这种情况时，您将不得不返回并重构这20个代码实现，因为您发现太晚了。当你这样做时，其他人都将领先于你。当你还在赶上时，他们会转向更新的编码新闻。

当React发布[钩子时](https://reactjs.org/docs/hooks-overview.html)，我非常兴奋。我开始构建一系列迷你项目来玩这些新玩具，每个人都被大肆宣传。在阅读了几个关于钩子稳定的消息来源后，我开始在我的项目中更认真地实施它们。我用的是`useState`和`useEffect`_无处不在_。

然后我遇到了一个链接到[这条推文的人](https://twitter.com/dan_abramov/status/1083330668522864640?lang=en)，这导致我做了更多的研究`useReducer`。这30分钟的研究足以让我回过头来重构大量的代码。

* * *

2.使用.bind（非类组件构造函数）
===================

我认为我们大多数React开发人员都知道，`.bind`如果我们想要引用`this` 他们的方法中访问自己的类实例，我们应该使用我们的类方法。（除非您使用[转换器](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)来转换您的类属性和方法。）

这很好，我也更喜欢用_箭头函数_声明类方法。

但我要谈的是_内联函数。_这些函数在react组件的_render方法_中定义，并作为prop传递给子组件。

当在render方法中定义内联函数时，每次组件重新呈现时，React都会开始指定一个新的函数实例。众所周知，由于[浪费的重新渲染](https://www.freecodecamp.org/news/how-to-identify-and-resolve-wasted-renders-in-react-cc4b1e910d10/)会导致性能问题。

我们来看看这个例子：

我们_知道_的是`onClick={() => sayWhereTheMoneyIs("I don't know")}`和`onClick={() => showThemTheMoney(0.05)}`是_内联函数_。

我已经看过几个鼓励这样做的教程（包括来自_Udemy_的教程）：

这似乎缓存了引用并避免了不必要的重新渲染，因为它们没有在render方法中使用箭头内联函数_。_但它们实际上仍然在每个渲染阶段[创建新功能](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind)！

如果您在类组件趋势发生时跟踪React生态系统中的社区，您可能已经知道了。

然而，自从React钩子被发布`.bind` 以来，由于类组件变得越来越不受欢迎，所以关于它的讨论越来越少。在`.bind`谈到时，人们通常会讨论绑定类方法。除此之外，上面的例子甚至根本没有绑定到类方法。如果你不小心，那就更难注意到这里的后果。

新人应该特别注意这种反模式！

* * *

3.将动态值作为子项的键传递
==============

你有没有觉得被迫为被映射的孩子提供独特的钥匙？提供独特的密钥是很好的：

现在假装某些`to`值`items1` 恰好与某些值相同`items2`。

当有些人想要重构类似的组件时，他们最终会做这样的事情：

这确实通过为每个孩子提供唯一键来完成工作。但有两件事是错的：

1.  我们不仅使React在生成唯一值时做了不必要的工作，而且我们也最终[在每次渲染](https://github.com/facebook/react/issues/1342)时[重新创建所有节点，因为每次键都不同](https://github.com/facebook/react/issues/1342)。
2.  反应中的_关键_概念是关于身份。并确定哪些部件是，按键_都_必须是唯一的，但不是这样的。

像这样的东西效果更好：

现在我们应该确信每个项目都有自己独特的键值，同时保留其身份。

* * *

4.声明超出Null的默认参数
===============

我曾经花了很多时间调试类似这样的东西：

在我们的_App_组件中，如果`dates` 最终是假的，它将被初始化为`null`。

当我们运行代码时，如果你像我一样，你的直觉告诉你，`items` 如果它是一个假值，那么默认情况下应该初始化为一个空数组。但是我们的应用程序会`dates`因为false而崩溃，因为它`items` 是null。什么？

如果[_没有_传递_值或未定义，_则](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)默认函数参数允许使用默认值初始化命名参数！

在我们的例子中，即使是假的，它仍然是一个价值！`null`

这个错误导致我花了很多时间调试代码，特别是当`null` 值来自redux reducer时！啊。

* * *

5.未经重复使用重复代码
============

当您急于推出修复时，复制和粘贴代码可能很诱人。有时，这样做可能是最快的解决方案。

这是重复代码的示例：

现在是开始思考如何以一种可以多次重用它们而不改变实现的方式来抽象这些组件的好时机。如果其中一个_Grid组件_相对于其周围的_Grid容器_存在样式问题，则必须手动更改它们中的每一个。

一种更好的编码方法是抽象出重复的部分并粘贴稍微不同的道具：

所以现在，如果你的老板最终改变主意并希望将所有这些部分的高度调整为_300px_，那么你只能在一个地方做出改变。

现在，如果您希望制作支持多个用例的组件，我不推荐这样的解决方案。这是针对特定用途，我们知道  它将仅在该环境中重复使用。对于`SectionContainer`支持多个用例的更加动态的可重用解决方案可能已被编码为更通用。你应该在_不_改变实现的_情况下_这样做：

这样，我们现在允许开发人员根据需要可选地扩展组件的任何部分，同时保留底层实现。

* * *

6.在构造函数中初始化道具
=============

在构造函数中初始化状态时：

你可能遇到错误。那是因为构造函数只调用一次，这是组件首次创建的时间。

下次尝试更改时`props`，状态将保留其先前的值，因为在重新渲染中不会调用构造函数。

如果您还没有遇到过这个问题，我希望这对您有所帮助！如果你想知道如何`props` 与状态同步，更好的方法是这样的：

* * *

7.带有&&的条件渲染
===========

有条件地渲染组件时常见的问题是使用 `&&`运算符。

如果条件不符合要求，React将尝试呈现您提供的任何内容作为替代输出。因此，当我们看到这个：

当空时，这实际上会在屏幕上呈现数字_0_。JavaScript将数字_0_视为[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)，因此当为空数组时，运算符将不会计算其右侧的表达式。它只会返回第一个值。`items.length` [](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)`items``_&&_`

如果我想保持语法，我通常做的是使用双重否定：

这样，如果`items`是一个空数组，如果计算的输出是布尔值，React将不会在屏幕上呈现任何内容。

* * *

8.不传播以前的国家
==========

偶尔会出现在我的错误列表中的东西来自于不小心实现状态更新逻辑。

最近的一个情况涉及React钩子，特别是一个`useReducer` 实现。这是一个成为问题的基本示例：

当`something`函数调用并复制状态时，底层`items`属性未更改。当我们使用它进行变异时`.splice`，这会发生变异`state.items`并引入错误。

在较大的代码中特别厌倦这一点。大家都可以或许得到过去类似上面的一个小例子，但是当事情变得一团糟，这_始终_必须牢记。很容易忘记这一点，特别是当你被迫将代码发送到生产时！

* * *

9.不明确地将道具传递给子组件
===============

通常，建议您明确使用传递给子组件的道具。

这有几个很好的理由：

1.  您有一个更简单的调试体验。
2.  作为开发人员，您_知道_传递给每个孩子的内容。
3.  其他开发人员也会知道并且将更容易阅读代码。
4.  更容易理解组件的功能。
5.  传递道具明确性的另一个好处是，当你这样做时，它也会以一种每个人都能理解而不需要正式文档的方式记录你的代码。这节省了时间！
6.  为了确定组件是否应该重新渲染，将需要_更少的_道具。

可以有一些非常巧妙的用例来传播所有的道具。例如，如果父母在将道具传递给子组件之前很快就需要一两件事，那么他们（和你）可以很容易地这样做：

只要确保你没有发现自己处于这种情况：

如果您这样做，请考虑将组件拆分为单独的组件，以使其更清晰，更可定制。

* * *

10.道具钻探
=======

将道具传递给多个子组件就是他们所说的 _代码味道_。

如果你不知道什么是螺旋钻，那就意味着父母将道具传递给树深处的多层组件。

现在，问题不在于父母或孩子。他们应该保持相同的实施。中间的组件可能会成为React应用程序中的一个问题。

那是因为现在中间的组件紧密耦合，并且暴露于他们不需要的太多信息。最糟糕的是，当父级重新渲染时，中间的组件也将重新渲染。这会为链中的所有子组件创建多米诺骨牌效应。

一个好的解决方案是使用[上下文](https://reactjs.org/docs/context.html)。或者，`redux`对于道具（因此将被序列化）。

结束这篇文章的结尾。希望你发现这篇文章有用！