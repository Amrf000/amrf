原文:![现代JavaScript开发中的设计模式](https://levelup.gitconnected.com/design-patterns-in-modern-javascript-development-ec84d8be06ca)
现代JavaScript开发中的设计模式
====================

关于软件项目设计中有效沟通的思考
----------------

[![克里斯蒂安·波斯莱克](https://miro.medium.com/fit/c/48/48/1*XmFGCbZ8kwc--WoBo9iS9Q.jpeg)](/@bojzi?source=post_page-----ec84d8be06ca----------------------)

[克里斯蒂安·波斯莱克](/@bojzi?source=post_page-----ec84d8be06ca----------------------)

跟随

[4月10日](/design-patterns-in-modern-javascript-development-ec84d8be06ca?source=post_page-----ec84d8be06ca----------------------) · 9 分钟阅读

![](https://miro.medium.com/max/30/1*nfNi7oUIZBakAdyXXcmirw.jpeg?q=20)

![](https://miro.medium.com/max/3648/1*nfNi7oUIZBakAdyXXcmirw.jpeg)

模式？设计？我们还在谈论软件开发吗？
==================

**当然。**

与面向对象编程一样，我们开发人员正试图模拟我们周围的世界。因此，尝试使用我们周围的世界作为描述我们工艺的工具是有意义的。

在这种情况下，我们从建筑（具有建筑物和桥梁的那个）和开创性的建筑书籍“ **A Pattern Language：Towns，Buildings，Construction** by _Christopher Alexander，Sara Ishikawa，Murray Silverstein”_中获取一个页面_，_其中的模式描述如下：

> 每个模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，以这种方式使您可以使用此解决方案一百万次，而无需以相同的方式执行两次。

在软件开发中，体系结构是以健康，健壮和可维护的方式构建应用程序的过程，模式提供了为常见问题的解决方案命名的方法。这些解决方案可以从抽象/概念到非常精确和技术，并允许开发人员有效地相互通信。

![](https://miro.medium.com/max/30/1*pdCoxUhmMHI5tBnGVdnNJQ.jpeg?q=20)

![](https://miro.medium.com/max/4000/1*pdCoxUhmMHI5tBnGVdnNJQ.jpeg)

高效。

如果团队中的两个或更多开发人员了解模式，那么谈论问题的解决方案就变得非常有效。如果只有一个开发人员了解模式，那么向团队的其他成员解释这些模式通常很容易。

**本文的目的是通过向您介绍软件设计模式的概念，并介绍一些有趣的模式，因为它们在现代JavaScript项目中被大量使用，从而激发您对软件开发中某种形式的知识表示的兴趣。**

单身模式
====

那是什么
----

单例模式不是最广泛使用的模式之一，但我们从这里开始，因为它相对容易掌握。

单例模式源于单例的数学概念，即：

> 在数学中，**单身**，也称为**单位集**，是一个只有一个元素的集合。例如，set {null}是一个单例。

在软件中，它只是意味着我们将类的实例化限制为单个对象。第一次实现单例模式的类的对象应该被实例化，它实际上将被实例化。任何后续尝试都将返回第一个实例。

![](https://miro.medium.com/max/30/1*JsnR25Uewd4wZLzZ-a9frg.png?q=20)

![](https://miro.medium.com/max/2826/1*JsnR25Uewd4wZLzZ-a9frg.png)

有蝙蝠侠时谁需要两个超级英雄？

为什么呢
----

除了允许我们只有一个超级英雄（显然是蝙蝠侠），为什么我们会使用单身模式？

虽然单身模式并非没有问题（在单身人士被[称为病态骗子](http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/)之前它被称为邪恶），但它仍有其用途。最值得注意的是实例化配置对象。除非应用程序的某项功能提供多种配置，否则您可能只需要一个适用于您的应用程序的配置实例。

在哪里
---

Angular的服务是在一个大型流行框架中使用的单例模式的一个主要例子。[Angular的文档中](https://angular.io/guide/singleton-services)有一个[专门的页面，](https://angular.io/guide/singleton-services)说明如何确保服务始终作为单例提供。

作为单例的服务很有意义，因为服务被用作存储状态，配置和允许组件之间通信的地方，并且您希望确保没有多个实例搞乱这些概念。

作为一个例子，假设您有一个简单的应用程序，用于计算按钮被点击的次数。

![](https://miro.medium.com/max/30/1*PZpt4afyPY10CnuRADJx5w.png?q=20)

![](https://miro.medium.com/max/2283/1*PZpt4afyPY10CnuRADJx5w.png)

您应该跟踪一个对象中按下按钮的次数，它提供：

*   计数的功能
*   并提供当前的点击次数。

如果该对象不是单例（并且每个按钮都会获得自己的实例），则点击计数将不正确。此外，您将向显示当前计数的组件提供哪些计数实例？

观察者模式
=====

那是什么
----

观察者模式定义如下：

> 该 **观察者模式** 是一种软件设计模式，其中一个对象称为 **学科**，维护一个名为的家属列表 **观察家**，并通常通过调用他们的方法之一自动通知他们任何状态变化。

如果我们尝试将它与现实世界中的一个例子 - 报纸订阅进行比较，那么理解观察者模式真的很容易。

购买报纸的通常情况是，你走到报摊，询问你最喜欢的报纸的新版本是否已经发布。如果不是这样，那么你必须走回家并稍后再试，这是一种无效率的悲惨事件。在JavaScript术语中，这将与循环相同，直到您获得所需的结果。  
当你终于把手放在报纸上时，你可以做你一直想做的事情 - 坐下来喝杯咖啡然后享受你的报纸（或者用JavaScript术语来执行你想做的回调功能全程）。

![](https://miro.medium.com/max/30/1*arrsn5kxG1GRbVpn7tlZkw.jpeg?q=20)

最后。

聪明的事情（每天得到你心爱的报纸）就是订阅报纸。  
这样一来，出版公司会告诉你什么时候出版新报并将它交给你。不再跑到报摊了。没有更多的失望。极乐。  
在JavaScript术语中，在您再次运行函数之前，不会循环并询问结果。相反，您可以让主题知道您对事件（消息）感兴趣，并提供一个回调函数，该函数应在新数据准备好时调用。那么，你是观察者。

![](https://miro.medium.com/max/30/1*Umz-GYQk5skILT07e0Kr4A.png?q=20)

再也不会错过你的晨报。

好消息是 - 您不必是唯一的订户。你会因为错过报纸而感到失望，其他人也会如此。这就是多个观察者可以订阅该主题的原因。

为什么呢
----

观察者模式有许多用例，但一般情况下，当你想要在没有紧密耦合的对象之间创建一对多依赖关系时，应该使用它，并且有可能让开放式数量的对象知道何时国家已经改变了。

JavaScript是一个可观察模式的好地方，因为一切都是事件驱动的，而不是总是询问事件是否发生，你应该让事件通知你（就像古老的格言_“不要打电话给我们，我们会打电话给你”_）。有可能你已经做了一些看起来像观察者模式的东西 - `addEventListener`。向元素添加事件侦听器具有观察者模式的所有标记：

*   你可以订阅这个对象，
*   你可以取消订阅该对象，
*   并且该对象可以向其所有订户广播事件。

通过了解观察者模式获得的巨大回报是，您可以更快地实现自己的主题或掌握现有的解决方案。

在哪里
---

实现一个基本的observable不应该太难，但是许多项目都使用了一个很棒的库，而[RactJS](https://github.com/ReactiveX/rxjs)就是它的[ReactiveX](http://reactivex.io/)，它的JavaScript对应物。[](https://github.com/ReactiveX/rxjs)

RxJS不仅允许您订阅主题，还允许您以您能想象的任何方式转换数据，组合多个订阅，使异步工作更易于管理等等。如果您想将数据处理和转换级别提升到更高的水平，RxJS将是一个很好的学习库。

除了观察者模式之外，ReactiveX还以实现迭代器模式而自豪，该模式使受试者有可能在订阅结束时让其订阅者知道，从而有效地结束了主题方的订阅。我不会在本文中解释迭代器模式，但是对于您来说，了解它并了解它如何适应可观察模式将是一个很好的练习。

门面模式
====

那是什么
----

立面图案是一种从建筑中取名的图案。在建筑中：

> 阿**立面**是建筑物，通常前的通常一个外侧。这是来自法国_外墙_的外国借词，意思是“正面”或“面子”。

由于建筑外立面是建筑物的外部，隐藏其内部工作，软件开发中的外观模式试图隐藏前面背后的潜在复杂性，有效地允许您使用更容易掌握的API，同时提供可能性根据需要更改底层代码。

为什么呢
----

您可以在无数种情况下使用外观模式，但最值得注意的是使代码更容易理解（隐藏复杂性）并使依赖关系尽可能松散耦合。

![](https://miro.medium.com/max/29/1*Unh3rSLKfaMzs3gweZF7UQ.png?q=20)

FUS RO DAH！

很容易理解为什么外观对象（或具有多个对象的图层）会是一件好事。如果可以避免，你不想与龙打交道。Facade对象将为您提供一个很好的API并处理所有龙的恶作剧本身。

我们在这里可以做的另一件好事是将龙从背景中更换而不会触及应用程序的其余部分。让我们说你想用小猫改变那条龙。它仍然有爪子，但更容易饲养。更改它是在不改变任何依赖对象的情况下重写外观中的代码。

在哪里
---

您将看到外观的地方通常是Angular使用其服务作为简化背景逻辑的手段。但它不必只是Angular，正如您将在下一个示例中看到的那样。

假设您要将状态管理添加到应用程序中。您可以选择Redux，NgRx，Akita，MobX，Apollo或左右弹出的任何新孩子。好吧，为什么不选择所有这些并带他们旋转呢？

州管理图书馆将为您提供哪些基本功能？

大概：

*   让州政府知道您想要改变状态的一种方式
*   以及获得当前（切片）状态的方法。

这听起来不太糟糕。

现在，在你的腰带的外观模式的力量，你可以写装饰门面其中要提供一个很好的API供您与工作状态的每个部分-有点像`facade.startSpinner()`，`facade.stopSpinner()`和`facade.getSpinnerState()`。这些方法非常容易理解和推理。

之后，您可以处理外观并编写将转换代码的代码，以便它可以与Apollo一起使用（使用GraphQL管理状态 - 现在非常热门）。您可能会注意到它根本不适合您的编码风格，或者单元测试的编写方式确实不是您的一杯茶。没问题，写一个支持MobX的新外观。

![](https://miro.medium.com/max/30/1*O3pSZ9xOfBkk7lO0CtGCPA.png?q=20)

也可能是龙......

从这往哪儿走
======

你可能已经注意到我所讨论的设计模式没有代码或实现。那是因为这些设计模式中的每一个都至少可以成为本书中的一章。

既然我们正在讨论书籍，那么深入了解一两个处理设计模式并不会有什么坏处。

第一个也是最大的建议必须是[**设计模式：**](http://wiki.c2.com/?DesignPatternsBook) _Erich Gamma_，_Richard Helm_，_Ralph Johnson_和_John Vlisside_ [**的可重复使用的面向对象软件**](http://wiki.c2.com/?DesignPatternsBook)  的[**元素，**](http://wiki.c2.com/?DesignPatternsBook)也被称为_Gang of Four_。这本书是一个金矿和软件设计模式的_事实上的_圣经。

如果你正在寻找的东西，这是一个有点容易消化，有[**Head First设计模式**](https://www.goodreads.com/book/show/58128.Head_First_Design_Patterns)由_伯特·贝茨_，_凯西塞拉利昂_，_埃里克·弗里曼_和_伊丽莎白·罗布森_。这是一本非常好的书，试图通过视觉角度传达设计模式的信息。

**最后但并非最不重要的是，没有什么能比谷歌搜索，阅读和尝试不同的方法。即使你最终从不使用模式或技术，你也会学到一些东西，并以你从未想到的方式成长。**

_插图中使用的语音气泡由_[_starline_](https://www.freepik.com/free-photos-vectors/frame)_创建_[_\- www.freepik.com_](https://www.freepik.com/free-photos-vectors/frame)_。_