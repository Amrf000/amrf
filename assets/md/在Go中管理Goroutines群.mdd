![在Go中管理Goroutines群](https://medium.com/swlh/managing-groups-of-gorutines-in-go-ee7523e3eaca)
在Go中管理Goroutines群
=================

[![米哈尔博克](https://miro.medium.com/fit/c/48/48/1*UNe99m8UrtLvRAS_zAHaNQ.jpeg)](/@michal.bock?source=post_page-----ee7523e3eaca----------------------)

[米哈尔博克](/@michal.bock?source=post_page-----ee7523e3eaca----------------------)

跟随

[8月30日](/swlh/managing-groups-of-gorutines-in-go-ee7523e3eaca?source=post_page-----ee7523e3eaca----------------------) · 7 分钟阅读

![](https://miro.medium.com/max/30/1*e8ZgpZvovR3HYH-tHhv9HQ.jpeg?q=20)

这张图片与本文没有任何关系，我只是喜欢它...

这是用于管理我发现自己每天使用的并发goroutine组的类型和模式的简要描述。从内置的等待组开始，继续前进到错误组。它模糊地遵循我自己发现这些的道路。

**让我们开始一些goroutines**
=====================

启动goroutine非常简单，你只需要在函数调用前添加关键字`go`。因此，作为该语言的新手，您可能希望此片段以某种随机顺序打印0到9之间的数字。我非常期待。

尝试在go [操场上](https://play.golang.org/p/qfCLKbod9bt)运行它。

但是，如果您尝试运行此小程序，则很可能看不到任何输出。这是因为程序运行的方式。Go总是执行调用`main`包中调用的`main`函数，一旦此函数终止，整个程序也会终止。这个程序最终做的是启动一堆goroutine，然后在它们有时间执行之前退出。

如果您尝试运行它几次，您可能会看到某些内容被注销，这是因为一个或多个goroutine在主函数终止之前设法执行。然而，这里的要点是，不能保证你开始的每个goroutine都会被执行，所以你需要自己照顾它。

标准库中有什么东西吗？
===========

go中的标准库非常广泛，所以你经常会发现解决问题的东西已经存在。在这种情况下也是如此，因为`sync`包具有一个有用的类型`WaitGroup`。我发现通过使用示例来解释类型的工作原理是最简单的，所以让我们看看上面使用等待组并按预期工作的程序的更新版本。

在[操场上](https://play.golang.org/p/4mz3y3gUvIf)试试吧。

Wait组实际上只是一个线程安全计数器，它暴露了以下三种方法：

*   `Add` 按指定金额增加（或减少）计数器的值。
*   `Done` 将计数器的值减一。
*   `Wait` 阻止，直到计数器的值为0。

为了确保在main函数终止之前已经执行了所有goroutine，我们在开始每个goroutine之前向计数器添加1。我们还在`Done`goroutine中执行的函数中调用延迟语句，以确保在函数终止后减少计数器（无论结果如何）。最后，我们`Wait`在启动所有goroutine之后调用它们等待它们完成。

请注意，`i`作为参数传入我们在goroutine中调用的函数非常重要，因为go会在当前goroutine中计算此函数的参数，然后才会启动新函数。如果`i`直接使用的函数将存在多个goroutine之间的数据争用，因为for循环`i`在每次迭代中重用。在这种情况下，例如，如果在循环结束后所有goroutine都已启动，则可能会看到10次打印10次。

错误怎么样？
======

到目前为止，这些例子非常简单，但非常理想化，因为他们没有预料到会发生任何错误。这不是在现实世界中做出的好假设，因此我们应该确保在生产代码中适当地处理错误。幸运的是，有一个包`golang.org/x/sync/errgroup`提供了一个围绕等待组的包装器来处理错误。

在探索错误组之前，让我们首先定义一个可以随机失败的作业函数。我们稍后会使用它。

此函数使用内置`rand`包生成0到11之间的随机整数。如果生成的数字等于作业ID，则作业失败并返回错误，否则成功。现在让我们看一个使用错误组和此工作函数的示例。

[操场上](https://play.golang.org/p/GSyt97yCQfn)的整个代码。在那里运行它似乎总是成功，所以也许尝试在你的机器上运行它。

这与我们之前使用等待组的方式非常相似，甚至可能更简单。我们只是创建组，然后在开始和分别完成之前，我们只是在错误组上调用函数，而不是自己启动gorout和调用`Add`和`Done`函数`Go`。这将在goroutine中启动提供的函数，然后立即返回，因此我们可以继续执行循环。请注意，在这种情况下，我们创建一个`i`名为的变量的副本`jobId`，它是循环的当前迭代的本地变量，以解决`i`在迭代之间重用的问题。

和之前一样，在启动goroutines之后，我们等待它们完成。但是，在这种情况下，该`Wait`函数返回错误。这是遇到的第一个错误，因此如果多个作业失败，我们将错过除第一个错误之外的所有错误。这通常很好，因为在大多数情况下，因为我们不希望任何事情失败。

背景怎么样？
======

在go中，通常的做法是使用`Context`内置`context`包中的接口来控制函数的执行。此接口具有一个`Done`函数，该函数返回一个上下文被取消后关闭的通道，当调用者不再对结果感兴趣时会发生这种情况。因此，将上下文作为参数的函数应检查完成的通道，以避免执行任何不必要的工作。

该`errgroup`包提供了一种通过调用`WithContext`函数使用上下文创建错误组的替代方法。此函数将上下文作为参数，并返回一个错误组以及一个上下文，该上下文是所提供的上下文的子项（这意味着每当父上下文被取消时，子项也会被取消）。

`WithContext`一旦错误组中启动的任何函数终止并出现错误，函数返回的上下文也将被取消。这将允许我们在遇到第一个错误时立即停止执行组中的其他作业。（请注意，一旦第一次调用`Wait`return 也会取消错误组上下文，因此无法重用上下文。）

所以让我们现在调整我们的工作来使用上下文。

这里我们添加了上下文作为第一个参数。请注意，每当函数使用上下文时，总是将上下文作为第一个参数。在函数的顶部，我们添加了一个select语句，该语句从`Done`上下文的通道和调用返回的通道中读取`time.After`。在创建后经过指定的持续时间后，将在时间通道上发送当前时间。这基本上执行随机休眠，可以通过上下文取消来中断，这将导致函数终止。其余功能与以前相同。

现在我们需要在main函数中使用上下文来创建错误组`WithContext`，并将返回的上下文传递给我们启动的所有作业。所以代码看起来像这样。

在go [操场上的](https://play.golang.org/p/NcyUhx2poBY)完整示例。

我们还能做的另一件事是在程序收到中断信号时尽量确保干净终止。为此，我喜欢使用由以下函数创建的上下文而不是从中返回的上下文`context.Background()`永远不会被取消。一旦程序收到中断信号，就会取消这个新的上下文，导致其所有子上下文（包括错误组1）的原因也被取消，从而确保清除终止。

通过这样的设置，我们应该能够处理遇到的任何错误，并在中断时干净地关闭。如果您不是100％确定所有这些设置，那么请自行尝试并查看此处提到的所有类型和功能的优秀文档。

如果错误组不正是我需要的怎么办？
================

错误组很棒，但有时我们可能需要稍微不同的行为。例如，我们可能有兴趣返回包含我们遇到的所有错误的切片而不仅仅是第一个切片。错误组不支持这样的行为，因此您可能会想要查看其源代码，并尝试对其进行调整以实现此目的。这是正确的做法，因为[代码](https://github.com/golang/sync/blob/master/errgroup/errgroup.go)非常简单，只包含66行代码，包括大文档字符串。交换`sync.Once`互斥锁和错误切片的单个错误将为我们提供我们想要的行为。

如果您想要随时可用的替代品，那么您可以尝试我们在`github.com/uw-labs/sync`包装中构建的替代品。它包含两个子包，其中`rungroup`一个类型的行为与错误组完全相同，只是它强制使用上下文，并且只要组中启动的任何函数终止，它就会取消基础上下文。这对于运行需要运行所有组件才能运行的管道非常有用。

调用另一个子包`gogroup`，它的行为类似于rungroup，除了`Wait`在组中第一个函数启动后立即返回的调用终止。这对于使用双向流实现gRPC服务器非常有用，因为它允许处理程序函数在服务器遇到错误时返回，即使goroutine仍在等待来自客户端的消息（示例可以在此[项目中](https://github.com/uw-labs/proximo)找到）。

我想这就是我现在要说的，请在评论中分享您对错误组的自适应。我很想看到它们。