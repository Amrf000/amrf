![操作JSON字段](https://medium.com/@egonelbre/manipulating-json-fields-f787d56bbd1d)
操作JSON字段
========

[![Egon Elbre](https://miro.medium.com/fit/c/48/48/1*F6Wll9z_5dhUXEj9h4VHZA.png)](/@egonelbre?source=post_page-----f787d56bbd1d----------------------)

[Egon Elbre](/@egonelbre?source=post_page-----f787d56bbd1d----------------------)

跟随

[2018年8月1日](/@egonelbre/manipulating-json-fields-f787d56bbd1d?source=post_page-----f787d56bbd1d----------------------) · 4 分钟阅读

_所有代码都可以在这里找到_[_https://github.com/egonelbre/exp/tree/master/fields_](https://github.com/egonelbre/exp/tree/master/fields)

在reddit上有一个问题：

在深入回答之前，首先深入研究这个问题总是有用的。很容易忘记实际问题是什么。通常通过创建更好的底层模型，我们可以完全简化或消除问题。

在几个问题之后我得到了[输入JSON看起来像这样](https://www.reddit.com/r/golang/comments/8y2zfc/looking_for_idiomatic_way_to_do_this/e29c1ud/?context=3)（略微简化）：

该程序的目标是编写根据名称计算这些值的代码。例如：

“Alpha”+“Gamma”= 25浮动

我们将忽略这篇文章中的乘数。不幸的是，他无法分享业务问题，这可能提供更多的洞察力。

接口
==

最初的实现基于使用接口。接口确实是处理类型可变性的解决方案之一。最基本的实现可能如下所示：

可以使用常规struct和unmarshal从JSON解析内容：

还有其他软件包可以提高性能，但它不是一个至关重要的部分，如果需要，我们可以随后将其切换出来。

现在的问题是，我们如何编写代码。只是写作`fields["Alpha"].Add(fields["Beta"])`，不起作用，因为我们只处理具有特定类型的东西。

类型开关
====

我猜蛮力实现可以使用类型开关来执行此操作：

我们使用“错误”字段类型来传播错误。它也可以通过手动错误传播或恐慌来完成，但Error字段似乎是一个很好的解决方案。最后，我们将把所有这些东西一起用作：

但是，已经实现了两种类型，单个操作变得非常冗长。每次新操作都会使情况恶化。

这种类型开关有一个变种。`Add`我们可以使用界面而不是使用具体类型`Field`。然而，这具有将所有不同`Field`实现联系在一起的问题。

func（a \* Uint）添加（b字段）字段{...

型地图
===

我们可以通过使用类型映射来避免一些样板，它创建了从类型到函数的映射：

对于每个“名称和类型对”，我们分配相应的功能。我们将通过使用正确的签名查找函数来实现通用的Add / Sub in。我们可以在[常春藤](https://github.com/robpike/ivy/blob/master/value/binary.go#L159)看到这种变化。它有一些很好的好处，比如简化类型促销。

但是，由于接口，我们最终会进行大量不同的类型转换以实现此目的。我们失去了语言给我们带来的所有类型安全性。同样，在指定功能时很容易出错。通过使用反射来查找func参数可以在一定程度上解决这个问题。

当我们需要混合多种类型并且“数学”来自最终用户而不是程序员时，这可能是一个非常好的解决方案。在那种情况下，我们无论如何都不能依赖语言类型安全。

反射
==

让我们考虑是否有必要使用不同的类型。当我们从一开始就拥有正确的类型时，我们就不必首先处理转换。

我们可以尝试在任意类型上实现类似于JSON unmarshaling的东西。在本质上：

为了使这个实现工作，我们首先需要将JSON数据解组成一个结构。这与之前的案例非常相似：

然后我们需要用反射遍历所有必要的字段。对于每个结果字段，我们还将从JSON中找到相应的字段。

最后将值分配给字段：

这个解决方案很好用，但是使用新类型扩展它会有点烦人。使用反射容易出错，容易遗漏特定情况。

组合序列化
=====

我们可以通过使用我称为[组合序列化](/@egonelbre/specification-types-ed9ddf35ec8f)的东西来避免反射。这就是我们编写`Field`接口的方式：

请注意，`Value`指针不是值本身。这允许我们将值分配给任意位置。我们可以分配如下值：

最后，我们可以将这些全部用在一起：

我们可以通过隐藏JSON部分来缩短它，但对于这个例子来说并不重要。整洁的是我们可以添加新的字段类型而无需更改扫描部分。当然，这种实现令人烦恼，因为必须两次明确地写出目标类型。

结论
==

这是如何以多种方式解决单个问题的另一个例子。我绝对跳过了许多可能的解决方案。请记住，这些都不是“最佳解决方案”，每个解决方案都有不同的权衡。

很容易陷入想要以特定方式解决问题的思维模式中。但是，总有很多解决方案。运用这种无限可能性的技能有助于找到花费更少时间实现更高效或更易于使用的解决方案。